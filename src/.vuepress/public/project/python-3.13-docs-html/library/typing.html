<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="typing —— 对类型提示的支持" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/typing.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码： Lib/typing.py 本模块提供了对类型提示的运行时支持。 考虑下面的函数: 函数 surface_area_of_cube 接受一个预期为 float 实例的参数，如 type hint edge_length: float 所指明的。 该函数预期返回一个 str 实例，如-> str 提示所指明的。 类型提示可以是简单的类比如 float 或 str ，它们也可以更为复杂..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="源代码： Lib/typing.py 本模块提供了对类型提示的运行时支持。 考虑下面的函数: 函数 surface_area_of_cube 接受一个预期为 float 实例的参数，如 type hint edge_length: float 所指明的。 该函数预期返回一个 str 实例，如-> str 提示所指明的。 类型提示可以是简单的类比如 float 或 str ，它们也可以更为复杂..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>typing —— 对类型提示的支持 &#8212; Python 3.13.2 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=23252803" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=ea36777e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.13.2 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="pydoc --- 文档生成器和在线帮助系统" href="pydoc.html" />
    <link rel="prev" title="开发工具" href="development.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" />
                <input type="submit" value="提交"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 对类型提示的支持</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">有关 Python 类型系统的规范说明</a></li>
<li><a class="reference internal" href="#type-aliases">类型别名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">标注可调用对象</a></li>
<li><a class="reference internal" href="#generics">泛型（Generic）</a></li>
<li><a class="reference internal" href="#annotating-tuples">标注元组</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">类对象的类型</a></li>
<li><a class="reference internal" href="#annotating-generators-and-coroutines">标注生成器和协程</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">用户定义的泛型类型</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 类型</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">名义子类型 vs 结构子类型</a></li>
<li><a class="reference internal" href="#module-contents">模块内容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特殊类型原语</a><ul>
<li><a class="reference internal" href="#special-types">特殊类型</a></li>
<li><a class="reference internal" href="#special-forms">特殊形式</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">构造泛型类型与类型别名</a></li>
<li><a class="reference internal" href="#other-special-directives">其他特殊指令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">协议</a></li>
<li><a class="reference internal" href="#abcs-for-working-with-io">与 IO 相关的抽象基类</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函数与装饰器</a></li>
<li><a class="reference internal" href="#introspection-helpers">内省辅助器</a></li>
<li><a class="reference internal" href="#constant">常量</a></li>
<li><a class="reference internal" href="#deprecated-aliases">一些已被弃用的别名</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">内置类型的别名</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 中的类型的别名。</a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">其他具体类型的别名</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中容器 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中异步 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中其他 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> ABC 的别名</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">主要特性的弃用时间线</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="development.html"
                          title="上一章">开发工具</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="pydoc.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文档生成器和在线帮助系统</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文档生成器和在线帮助系统"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 对类型提示的支持</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="typing-support-for-type-hints">
<h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> —— 对类型提示的支持<a class="headerlink" href="#typing-support-for-type-hints" title="Link to this heading">¶</a></h1>
<div class="versionadded" id="module-typing">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p><strong>源代码：</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Python 运行时不强制要求函数与变量类型标注。 它们可被 <a class="reference internal" href="../glossary.html#term-static-type-checker"><span class="xref std std-term">类型检查器</span></a>、IDE、语法检查器等第三方工具使用。</p>
</div>
<hr class="docutils" />
<p>本模块提供了对类型提示的运行时支持。</p>
<p>考虑下面的函数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">surface_area_of_cube</span><span class="p">(</span><span class="n">edge_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;The surface area of the cube is </span><span class="si">{</span><span class="mi">6</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">edge_length</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">.&quot;</span>
</pre></div>
</div>
<p>函数 <code class="docutils literal notranslate"><span class="pre">surface_area_of_cube</span></code> 接受一个预期为 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 实例的参数，如 <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hint</span></a> <code class="docutils literal notranslate"><span class="pre">edge_length:</span> <span class="pre">float</span></code> 所指明的。 该函数预期返回一个 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 实例，如 <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">str</span></code> 提示所指明的。</p>
<p>类型提示可以是简单的类比如 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 或 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，它们也可以更为复杂。 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块提供了一套用于更高级类型提示的词汇。</p>
<p>新特性被频繁添加到 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块中。 <a class="extlink-pypi reference external" href="https://pypi.org/project/typing_extensions/">typing_extensions</a> 包提供了这些新特性针对较旧版本 Python 的向下移植。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">&quot;类型系统备忘单&quot;</a></dt><dd><p>关于类型提示的概览（发布于 mypy 文档站点）</p>
</dd>
<dt><a class="reference external" href="https://mypy.readthedocs.io/en/stable/index.html">mypy 文档</a> 的 &quot;Type System Reference&quot; 章节</dt><dd><p>Python 类型系统是通过 PEP 来标准化的，因此该参考应当广泛适用于大多数 Python 类型检查器。 （但某些部分仍然是 mypy 专属的。）</p>
</dd>
<dt><a class="reference external" href="https://typing.readthedocs.io/en/latest/">&quot;Static Typing with Python&quot;</a></dt><dd><p>由社区编写的不限定具体类型检查器的文档，详细讲解了类型系统特性，有用的类型相关工具以及类型的最佳实践。</p>
</dd>
</dl>
</div>
<section id="specification-for-the-python-type-system">
<span id="relevant-peps"></span><h2>有关 Python 类型系统的规范说明<a class="headerlink" href="#specification-for-the-python-type-system" title="Link to this heading">¶</a></h2>
<p>Python 类型系统最新的规范说明可以在 <a class="reference external" href="https://typing.readthedocs.io/en/latest/spec/index.html">&quot;Specification for the Python type system&quot;</a> 查看。</p>
</section>
<section id="type-aliases">
<span id="id2"></span><h2>类型别名<a class="headerlink" href="#type-aliases" title="Link to this heading">¶</a></h2>
<p>类型别名是使用 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句来定义的，它将创建一个 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的实例。 在这个示例中，<code class="docutils literal notranslate"><span class="pre">Vector</span></code> 和 <code class="docutils literal notranslate"><span class="pre">list[float]</span></code> 将被静态类型检查器等同处理:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># 通过类型检查；浮点数列表是合格的 Vector。</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>类型别名适用于简化复杂的类型签名。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="nb">type</span> <span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 静态类型检查器会认为上面的类型签名</span>
<span class="c1"># 完全等价于下面这个写法。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_message</span><span class="p">(</span>
    <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句是在 Python 3.12 中新增加的。 为了向下兼容，类型别名也可以通过简单的赋值来创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p>或者用 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 标记来显式说明这是一个类型别名，而非一般的变量赋值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Vector</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="Link to this heading">¶</a></h2>
<p>用 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> 助手创建与原类型不同的类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 通过类型检查</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># 未通过类型检查；整数不能作为 UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 类型的变量可执行所有 <code class="docutils literal notranslate"><span class="pre">int</span></code> 操作，但返回结果都是 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型。这种方式允许在预期 <code class="docutils literal notranslate"><span class="pre">int</span></code> 时传入 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>，还能防止意外创建无效的 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; 的类型为 &#39;int&#39; 而非 &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>注意，这些检查只由静态类型检查器强制执行。在运行时，语句 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> 将产生一个 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 可调用对象，该对象立即返回你传递给它的任何参数。 这意味着语句 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 不会创建一个新的类，也不会引入超出常规函数调用的很多开销。</p>
<p>更确切地说，在运行时，<code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> 表达式总为 True。</p>
<p>创建 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的子类型是无效的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># 将在运行时失败且无法通过类型检查</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>然而，我们可以在 &quot;派生的&quot; <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的基础上创建一个 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>同时，<code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> 的类型检查也可以按预期执行。</p>
<p>详见 <span class="target" id="index-156"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>请记住使用类型别名将声明两个类型是相互 <em>等价</em> 的。 使用 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> 将使静态类型检查器在任何情况下都把 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> 视为与 <code class="docutils literal notranslate"><span class="pre">Original</span></code> <em>完全等价</em>。 这在你想要简化复杂的类型签名时会很有用处。</p>
<p>反之，<code class="docutils literal notranslate"><span class="pre">NewType</span></code> 声明把一种类型当作另一种类型的 <em>子类型</em>。<code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> 时，静态类型检查器把 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 当作 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的 <em>子类</em> ，即，<code class="docutils literal notranslate"><span class="pre">Original</span></code> 类型的值不能用在预期 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 类型的位置。这种方式适用于以最小运行时成本防止逻辑错误。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是一个函数。 因此，当调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 而非常规函数时会有一些额外的运行时开销。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的性能已恢复到 Python 3.9 时的水平。</p>
</div>
</section>
<section id="annotating-callable-objects">
<span id="annotating-callables"></span><h2>标注可调用对象<a class="headerlink" href="#annotating-callable-objects" title="Link to this heading">¶</a></h2>
<p>函数 -- 或是其他 <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a> 对象 -- 可以使用 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 或已被弃用的 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Callable</span></code></a> 来标注。 <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> 表示一个接受 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 类型的单个形参并返回一个 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的函数。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Awaitable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># 函数体</span>

<span class="k">def</span><span class="w"> </span><span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># 函数体</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># 函数体</span>

<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>下标语法总是要刚好使用两个值：参数列表和返回类型。 参数列表必须是一个由类型组成的列表、<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>、<a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 或省略号。 返回类型必须是单一类型。</p>
<p>如果将一个省略号字面值 <code class="docutils literal notranslate"><span class="pre">...</span></code> 作为参数列表，则表示可以接受包含任意形参列表的可调用对象:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">str</span>     <span class="c1"># 可以</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">concat</span>  <span class="c1"># 同样可以</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 无法表达复杂的签名如接受可变数量参数的函数，<a class="reference internal" href="#overload"><span class="std std-ref">重载的函数</span></a>，或具有仅限关键字形参的函数。 但是，这些签名可通过自定义具有 <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法的 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 类来表达：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Combiner</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">batch_proc</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">cb_results</span><span class="p">:</span> <span class="n">Combiner</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">good_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bad_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxitems</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">good_cb</span><span class="p">)</span>  <span class="c1"># 可以</span>
<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">bad_cb</span><span class="p">)</span>   <span class="c1"># 错误！参数 2 的类型不兼容</span>
                         <span class="c1"># 因为在回调中有不同的名称和类别</span>
</pre></div>
</div>
<p>以其他可调用对象为参数的可调用对象可以使用 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 来表明其参数类型是相互依赖的。 此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 操作符。 它们分别采取 <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> 的形式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 详情见 <span class="target" id="index-157"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 的文档提供了在 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 中使用的例子。</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2>泛型（Generic）<a class="headerlink" href="#generics" title="Link to this heading">¶</a></h2>
<p>由于无法以通用方式静态地推断容器中保存的对象的类型信息，标准库中的许多容器类都支持下标操作来以表示容器元素的预期类型。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">:</span> <span class="o">...</span>

<span class="c1"># Sequence[Employee] 表明该序列中的所有元素</span>
<span class="c1"># 都必须是 &quot;Employee&quot; 的实例。</span>
<span class="c1"># Mapping[str, str] 表明该映射中的所有键和所有值</span>
<span class="c1"># 都必须是字符串。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>泛型函数和类可以通过使用 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参语法</span></a> 来实现参数化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>  <span class="c1"># 函数是 TypeVar &quot;T&quot; 泛型</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>或直接使用 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 工厂：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>                  <span class="c1"># 声明类型变量 &quot;U&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">second</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># 函数是 TypeVar &quot;U&quot; 泛型</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对泛型的语法支持是在 Python 3.12 中新增的。</p>
</div>
</section>
<section id="annotating-tuples">
<span id="id4"></span><h2>标注元组<a class="headerlink" href="#annotating-tuples" title="Link to this heading">¶</a></h2>
<p>对于 Python 中的大多数容器，类型系统会假定容器中的所有元素都是相同类型的。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span>

<span class="c1"># 类型检查器将推断 ``x`` 中的所有元素均为整数</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 类型检查器错误: ``list`` 只接受单个类型参数：</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]</span>

<span class="c1"># 类型检查器将推断 ``z`` 中的所有键均为字符串，</span>
<span class="c1"># 并且 ``z`` 中的所有值均为字符串或整数</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 只接受一个类型参数，因此类型检查器将在上述代码中对 <code class="docutils literal notranslate"><span class="pre">y</span></code> 赋值时报告错误。同样，<a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 只接受两个类型参数：第一个给出键的类型，第二个则给出值的类型。</p>
<p>然而，与大多数其它 Python 容器不同的是，在常见的 Python 代码中，元组中元素的类型并不相同。因此，在 Python 的类型系统中，元组是特殊情况。<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 可以接受 <em>任意数量</em> 的类型参数：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 可以: ``x`` 被赋值为长度为 1 的元组，其中的唯一元素是个整数</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>

<span class="c1"># 可以: ``y`` 被赋值为长度为 2 的元素；</span>
<span class="c1"># 第 1 个元素是个整数，第 2 个元素是个字符串</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># 错误: 类型标注表明是长度为 1 的元组，</span>
<span class="c1"># 但 ``z`` 却被赋值为长度为 3 的元组</span>
<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>要表示一个可以是 <em>任意</em> 长度的元组，并且其中的所有元素都是相同类型的 <code class="docutils literal notranslate"><span class="pre">T</span></code>，请使用 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">...]</span></code>。要表示空元组，请使用 <code class="docutils literal notranslate"><span class="pre">tuple[()]</span></code>。只使用 <code class="docutils literal notranslate"><span class="pre">tuple</span></code> 作为注解等效于使用``tuple[Any, ...]``：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># 这些赋值是可以的 OK: ``tuple[int, ...]`` 表明 x 可以为任意长度</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1"># 这个赋值是错误的: ``x`` 中的所有元素都必须为整数</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="c1"># ``y`` 只能被赋值为一个空元组</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[()]</span> <span class="o">=</span> <span class="p">()</span>

<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="c1"># 这些重新赋值是可以的 OK: 简单的 ``tuple`` 等价于 ``tuple[Any, ...]``</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
</section>
<section id="the-type-of-class-objects">
<span id="type-of-class-objects"></span><h2>类对象的类型<a class="headerlink" href="#the-type-of-class-objects" title="Link to this heading">¶</a></h2>
<p>带有 <code class="docutils literal notranslate"><span class="pre">C</span></code> 标注的变量可接受 <code class="docutils literal notranslate"><span class="pre">C</span></code> 类型的值。 反之，带有 <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> (或已被弃用的 <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Type[C]</span></code></a>) 标注的变量则可接受本身是类的值 -- 准确地说，它将接受 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的 <em>类对象</em>。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># 为 ``int`` 类型</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># 为 ``type[int]`` 类型</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 同样为 ``type[int]`` 类型</span>
</pre></div>
</div>
<p>注意，<code class="docutils literal notranslate"><span class="pre">type[C]</span></code> 是协变的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>

<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>      <span class="c1"># 可以</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>   <span class="c1"># 同样可以: ``type[ProUser]`` 是 ``type[User]`` 的子类型</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>  <span class="c1"># 仍然可以</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">())</span>    <span class="c1"># 错误: 预期为 ``type[User]`` 但得到 ``User``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>       <span class="c1"># 错误: ``type[int]`` 不是 ``type[User]`` 的子类型</span>
</pre></div>
</div>
<p><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的合法形参只有类, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">类型变量</span></a> 以及前面这些类型的并集。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">BasicUser</span><span class="p">)</span>  <span class="c1"># 可以</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>    <span class="c1"># 可以</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>   <span class="c1"># 错误: ``type[TeamUser]`` 不是</span>
                              <span class="c1"># ``type[BasicUser | ProUser]`` 的子类型</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>       <span class="c1"># 同样错误</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type[Any]</span></code> 等价于 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>，它是 Python 的 <a class="reference internal" href="../reference/datamodel.html#metaclasses"><span class="std std-ref">元类层级结构</span></a> 的根对象。</p>
</section>
<section id="annotating-generators-and-coroutines">
<span id="id5"></span><h2>标注生成器和协程<a class="headerlink" href="#annotating-generators-and-coroutines" title="Link to this heading">¶</a></h2>
<p>生成器可以使用泛型类型 <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code></a> 来标。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>请注意与标准库里的许多其他泛型类不同，<a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 采用逆变行为，而不是协变或不变行为。</p>
<p><code class="docutils literal notranslate"><span class="pre">SendType</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 形参默认为 <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>也可以显式设置这些类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>仅产生值的简单生成器可以被标注为具有 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code></a> 或 <a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code></a> 类型的返回值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>异步生成器的处理方式类似，但不要指望有 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 类型参数 (<a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code></a>)。 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 参数默认为 <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>，因此以下定义是等价的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>与同步情况一样，<a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code></a> 和 <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code></a> 也可用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>协程可使用 <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code></a> 进行注释。 泛型参数对应于 <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的参数，例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># 在其他地方定义的协程</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># 推断 &#39;x&#39; 的类型为 list[str]</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># 推断 &#39;y&#39; 的类型为 int</span>
</pre></div>
</div>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>用户定义的泛型类型<a class="headerlink" href="#user-defined-generic-types" title="Link to this heading">¶</a></h2>
<p>用户定义的类可以定义为泛型类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">Logger</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LoggedVar</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>这种语法表示类 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> 是围绕单个 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> <code class="docutils literal notranslate"><span class="pre">T</span></code> 实现参数化的。 这也使得 <code class="docutils literal notranslate"><span class="pre">T</span></code> 成为类体内部有效的类型。</p>
<p>泛型类隐式继承自 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。为了与 Python 3.11 及更低版本兼容，也允许显式地从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 继承以表示泛型类：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型类具有 <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> 方法，这意味着泛型类可在运行时进行参数化（例如下面的 <code class="docutils literal notranslate"><span class="pre">LoggedVar[int]</span></code>）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>一个泛型可以有任何数量的类型变量。所有种类的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 都可以作为泛型的参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span><span class="w"> </span><span class="nc">WeirdTrio</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]:</span>
    <span class="o">...</span>

<span class="n">OldT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldT&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldB</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldB&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldS</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldS&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OldWeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">OldT</span><span class="p">,</span> <span class="n">OldB</span><span class="p">,</span> <span class="n">OldS</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 类型变量的参数应各不相同。下列代码就是无效的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">]:</span>  <span class="c1"># SyntaxError</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># 无效</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>泛型类也可以从其他类继承：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sized</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LinkedList</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Sized</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>从泛型类继承时，某些类型参数可被固定：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyDict</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>在这个例子中，<code class="docutils literal notranslate"><span class="pre">MyDict</span></code> 就只有一个参数 <code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>未指定泛型类的类型参数时，会假定每个位置的类型都为 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。在下面的例子中，<code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> 不是泛型，但却隐式继承了 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># 与 Iterable[Any] 相同</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>用户定义的泛型类型别名也同样受到支持。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="nb">type</span> <span class="n">Response</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># 这里的返回类型与 Iterable[str] | int 相同</span>
<span class="k">def</span><span class="w"> </span><span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">inproduct</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)](</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># 与 Iterable[tuple[T, T]] 相同</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>出于向后兼容性的考虑，也允许使用简单的赋值来创建泛型类型别名：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 不再支持自定义元类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>3.12 版本新增了对泛型和类型别名的语法支持。在之前的版本中，泛型类必须显式继承自 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>，或者在其基类之一中包含有类型变量。</p>
</div>
<p>用户定义的参数表达式的泛型也受到支持，可以采用 <code class="docutils literal notranslate"><span class="pre">[**P]</span></code> 形式的参数规格变量来表示。该行为与上面描述的类型变量一致，因为参数规格变量被 typing 模块视为专门的类型变量。这方面的一个例外是，类型的列表可用于替代 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># T 为 TypeVar；P 为 ParamSpec</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, [dict, float]]</span>
</pre></div>
</div>
<p>带有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型类也可以使用从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 显式继承的方式来创建。在这种情况下，不需要使用 <code class="docutils literal notranslate"><span class="pre">**</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 与 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的另一个区别在于只有单个参数规格变量的泛型会接受形如 <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> 的参数列表，同时为了美观，也接受 <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> 这样的形式。 在内部，后者被转换为前者，所以下面的内容是等价的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[[int, str]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[[int, str]]</span>
</pre></div>
</div>
<p>请注意：在某些情况下，具有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型在替换后可能不具有正确的 <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code>，因为参数规格主要用于静态类型检查。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 现在可以通过参数表达式进行参数化。参见 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <span class="target" id="index-158"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> 以了解更多细节。</p>
</div>
<p>用户定义的泛型类可以将 ABC 作为基类而不会导致元类冲突。 参数化泛型的输出结果会被缓存，且 typing 模块中的大多数类型都是 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> 并且支持相等性比较。</p>
</section>
<section id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型<a class="headerlink" href="#the-any-type" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 是一种特殊的类型。静态类型检查器认为所有类型均与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容，同样，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 也与所有类型兼容。</p>
<p>也就是说，可对 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值执行任何操作或方法调用，并赋值给任意变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># 可以</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># 可以</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># 可以</span>

<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 通过类型检查；&#39;item&#39; 可以为任意类型，</span>
    <span class="c1"># 并且其类型会具有 &#39;bar&#39; 方法</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>注意，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值赋给更精确的类型时，不执行类型检查。例如，把 <code class="docutils literal notranslate"><span class="pre">a</span></code> 赋给 <code class="docutils literal notranslate"><span class="pre">s</span></code>，在运行时，即便 <code class="docutils literal notranslate"><span class="pre">s</span></code> 已声明为 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型，但接收 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 值时，静态类型检查器也不会报错。</p>
<p>此外，未指定返回值与参数类型的函数，都隐式地默认使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># 静态类型检查器将认为上面的函数</span>
<span class="c1"># 具有与下面的函数相同的签名：</span>
<span class="k">def</span><span class="w"> </span><span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>需要混用动态与静态类型代码时，此操作把 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 当作 <em>应急出口</em>。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 和 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的区别。与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相似，所有类型都是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的子类型。然而，与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 不同，object 不可逆：<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>不是</em> 其它类型的子类型。</p>
<p>就是说，值的类型是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 时，类型检查器几乎会拒绝所有对它的操作，并且，把它赋给更精确的类型变量（或返回值）属于类型错误。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 不能通过类型检查；对象没有 &#39;magic&#39; 方法。</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 通过类型检查</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># 通过类型检查，因为整数和字符串都是 object 的子类</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># 通过类型检查，因为 Any 可以兼容所有类型</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>，说明值能以类型安全的方式转为任何类型。使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，说明值是动态类型。</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>名义子类型 vs 结构子类型<a class="headerlink" href="#nominal-vs-structural-subtyping" title="Link to this heading">¶</a></h2>
<p>最初 <span class="target" id="index-159"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 将 Python 静态类型系统定义为使用 <em>名义子类型</em>。这意味着当且仅当类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的子类时，才满足有类 <code class="docutils literal notranslate"><span class="pre">B</span></code> 预期时使用类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 。</p>
<p>此项要求以前也适用于抽象基类，例如，<a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 。这种方式的问题在于，定义类时必须显式说明，既不 Pythonic，也不是动态类型式 Python 代码的惯用写法。例如，下列代码就遵从了 <span class="target" id="index-160"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 的规范：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-161"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> 允许用户在类定义时不显式说明基类，从而解决了这一问题，静态类型检查器隐式认为 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> 既是 <code class="docutils literal notranslate"><span class="pre">Sized</span></code> 的子类型，又是 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code> 的子类型。这就是 <em>结构子类型</em> （又称为静态鸭子类型）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># 注意：没有基类</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># 通过类型检查</span>
</pre></div>
</div>
<p>此外，结构子类型的优势在于，通过继承特殊类 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> ，用户可以定义新的自定义协议（见下文中的例子）。</p>
</section>
<section id="module-contents">
<h2>模块内容<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块定义了下列类、函数和装饰器。</p>
<section id="special-typing-primitives">
<h3>特殊类型原语<a class="headerlink" href="#special-typing-primitives" title="Link to this heading">¶</a></h3>
<section id="special-types">
<h4>特殊类型<a class="headerlink" href="#special-types" title="Link to this heading">¶</a></h4>
<p>这些类型可用于在注解中表示类型，但不支持下标用法（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Any">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Any</span></span><a class="headerlink" href="#typing.Any" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型，表示没有约束的类型。</p>
<ul class="simple">
<li><p>所有类型都与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容。</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 与所有类型都兼容。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 现在可以用作基类。这有助于避免类型检查器在高度动态或可通过鸭子类型使用的类上报错。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.AnyStr">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AnyStr</span></span><a class="headerlink" href="#typing.AnyStr" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#typing-constrained-typevar"><span class="std std-ref">受约束的类型变量</span></a>。</p>
<p>定义：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 用于可接受 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 或 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 参数但不允许两者混用的函数。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>    <span class="c1"># 可以，输出为 &#39;str&#39; 类型</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># 可以，输出为 &#39;bytes&#39; 类型</span>
<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>   <span class="c1"># 错误，不可混用 str 和 bytes</span>
</pre></div>
</div>
<p>请注意：尽管名为 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>，但它与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal notranslate"><span class="pre">Any</span></code></a> 类型毫无关系，也不是指“任何字符串”。而且，<code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 更是和 <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes</span></code> 彼此互不相同，各有各的使用场景：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># AnyStr 的无效使用:</span>
<span class="c1"># 类型变量在函数签名中仅使用一次，</span>
<span class="c1"># 因此无法通过类型检查器“解决”</span>
<span class="k">def</span><span class="w"> </span><span class="nf">greet_bad</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>

<span class="c1"># 注释此函数的更好方法:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">greet_proper</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>
</pre></div>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.18: </span>已被弃用而应改用新的 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参语法</span></a>。 使用 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">A[T:</span> <span class="pre">(str,</span> <span class="pre">bytes)]:</span> <span class="pre">...</span></code> 而不是导入 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>。 详情参见 <span class="target" id="index-162"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>。</p>
<p>在 Python 3.16 中，<code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 将从 <code class="docutils literal notranslate"><span class="pre">typing.__all__</span></code> 中被移除，在运行时当它被访问或从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入时将发出弃用警告。 在 Python 3.18 中 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 将从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 中被移除。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.LiteralString">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">LiteralString</span></span><a class="headerlink" href="#typing.LiteralString" title="Link to this definition">¶</a></dt>
<dd><p>只包括字符串字面值的的特殊类型。</p>
<p>任何字符串字面值或其他 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 都与 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 兼容。但 <code class="docutils literal notranslate"><span class="pre">str</span></code> 类型的对象不与其兼容。组合 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 类型的对象产生的字符串也被认为是 <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>。</p>
<p>示例:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">caller</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">literal_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>  <span class="c1"># 可以</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># 可以</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># 可以</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>  <span class="c1"># 类型检查器错误</span>
    <span class="n">run_query</span><span class="p">(</span>  <span class="c1"># 类型检查器错误</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> 对于会因用户可输入任意字符串而导致问题的敏感 API 很有用。例如，上述两处导致类型检查器报错的代码可能容易被 SQL 注入攻击。</p>
<p>请参阅 <span class="target" id="index-163"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Never</span></span><a class="headerlink" href="#typing.Never" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.NoReturn">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoReturn</span></span><a class="headerlink" href="#typing.NoReturn" title="Link to this definition">¶</a></dt>
<dd><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 代表 <a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">底类型</a>，一种没有成员的类型。</p>
<p>它们可被用于指明一个函数绝不会返回，例如 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># 或 NoReturn</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者用于定义一个绝不应被调用的函数，因为不存在有效的参数，例如 <a class="reference internal" href="#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">assert_never()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># 或 NoReturn</span>

<span class="k">def</span><span class="w"> </span><span class="nf">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># 类型检查器错误</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># OK, arg is of type Never (or NoReturn)</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> 和 <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> 在类型系统中具有相同的含义并且静态类型检查器会以相同的方式对待这两者。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2: </span>增加了 <a class="reference internal" href="#typing.NoReturn" title="typing.NoReturn"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>增加了 <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Self">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Self</span></span><a class="headerlink" href="#typing.Self" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型，表示当前闭包内的类。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span><span class="p">,</span> <span class="n">reveal_type</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SubclassOfFoo</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># 揭示的类型为 &quot;Foo&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">SubclassOfFoo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># 揭示的类型为 &quot;SubclassOfFoo&quot;</span>
</pre></div>
</div>
<p>此注解在语法上等价于以下代码，但形式更为简洁：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>通常来说，如果某些内容返回 <code class="docutils literal notranslate"><span class="pre">self</span></code>，如上面的示例所示，您应该使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 作为返回值注解。如果 <code class="docutils literal notranslate"><span class="pre">Foo.return_self</span></code> 被注解为返回 <code class="docutils literal notranslate"><span class="pre">&quot;Foo&quot;</span></code>，那么类型检查器将推断从 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo.return_self</span></code> 返回的对象是 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类型，而不是 <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo</span></code>。</p>
<p>其它常见用例包括：</p>
<ul class="simple">
<li><p>被用作替代构造器的 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>，它将返回 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 形参的实例。</p></li>
<li><p>标注一个返回自身的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法。</p></li>
</ul>
<p>如果不能保证在子类中方法会返回子类的实例（而非父类的实例），则不应使用 <code class="docutils literal notranslate"><span class="pre">Self</span></code> 作为返回值注解：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Eggs</span><span class="p">:</span>
    <span class="c1"># 在这里 self 是一个不正确的返回注释,</span>
    <span class="c1"># 因为返回的对象始终是 Eggs 的一个实例,</span>
    <span class="c1"># 即使在子类中</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">returns_eggs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Eggs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eggs</span><span class="p">()</span>
</pre></div>
</div>
<p>更多细节请参见 <span class="target" id="index-164"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeAlias">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAlias</span></span><a class="headerlink" href="#typing.TypeAlias" title="Link to this definition">¶</a></dt>
<dd><p>特殊注解，用于显式声明 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a>.</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>在较早的 Python 版本上，<code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> 对注解使用前向引用的别名时特别有用，因为类型检查器可能很难将这些别名与正常的变量赋值区分开来：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="c1"># &quot;Box&quot; 还不存在,</span>
<span class="c1"># 因此我们必须在 Python &lt;3.12 版本中使用引号进行前向引用。</span>
<span class="c1"># 使用 ``TypeAlias`` 告诉类型检查器这是一个类型别名声明，</span>
<span class="c1"># 而不是对字符串的变量赋值。</span>
<span class="n">BoxOfStrings</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Box[str]&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_box_of_strings</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoxOfStrings</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-165"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a> 了解详情。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 被弃用，请使用 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句，后者创建 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 的实例，并且天然支持正向引用。请注意，虽然 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 和 <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> 具有相似的用途和名称，但它们是不同的，后者并不是前者的类型。目前还没有移除 <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> 的计划，但鼓励用户迁移到 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句。</p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>特殊形式<a class="headerlink" href="#special-forms" title="Link to this heading">¶</a></h4>
<p>这些内容在注解中可以视为类型，且都支持下标用法（<code class="docutils literal notranslate"><span class="pre">[]</span></code>），但每个都有唯一的语法。</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Union">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><a class="headerlink" href="#typing.Union" title="Link to this definition">¶</a></dt>
<dd><p>联合类型； <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> ，意味着满足 X 或 Y 之一。</p>
<p>要定义一个联合类型，可以使用类似 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> 或简写 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>。建议使用这种简写。细节:</p>
<ul>
<li><p>参数必须是某种类型，且至少有一个。</p></li>
<li><p>联合类型之联合类型会被展平，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>单参数之联合类型就是该参数自身，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># 该构造器确实返回 int</span>
</pre></div>
</div>
</li>
<li><p>冗余的参数会被跳过，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>比较联合类型，不涉及参数顺序，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>不可创建 <code class="docutils literal notranslate"><span class="pre">Union</span></code> 的子类或实例。</p></li>
<li><p>没有 <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code> 这种写法。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>在运行时，不要移除联合类型中的显式子类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>联合类型现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>。 参见 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Optional">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Optional</span></span><a class="headerlink" href="#typing.Optional" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> （或 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> ） 。</p>
<p>注意，可选类型与含默认值的可选参数不同。含默认值的可选参数不需要在类型注解上添加 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 限定符，因为它仅是可选的。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>另一方面，显式应用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值时，不管该参数是否可选， <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 都适用。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>可选参数现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>。 参见 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Concatenate">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Concatenate</span></span><a class="headerlink" href="#typing.Concatenate" title="Link to this definition">¶</a></dt>
<dd><p>特殊形式，用于注解高阶函数。</p>
<p><code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可用于与 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 和 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 连用来注解高阶可调用对象，该可象可以添加、移除或转换另一个可调用对象的形参。  使用形式为 <code class="docutils literal notranslate"><span class="pre">Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable]</span></code>。 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 目前仅可用作传给 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 的第一个参数。传给 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的最后一个形参必须是 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 或省略号（ <code class="docutils literal notranslate"><span class="pre">...</span></code> ）。</p>
<p>例如，为了注释一个装饰器 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code>，它为被装饰的函数提供了 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>，<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可以用来表示 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> 期望一个可调用对象，该对象接收一个 <code class="docutils literal notranslate"><span class="pre">Lock</span></code> 作为第一个参数，并返回一个具有不同类型签名的可调用对象。 在这种情况下，<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 表示返回的可调用对象的参数类型取决于被传入的可调用程序的参数类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Concatenate</span>

<span class="c1"># 使用此锁来确保在任何时候只有一个线程正在执行某个函数。</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">with_lock</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># 由于装饰器的存在，我们不需要自己传递锁。</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-166"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）</p></li>
<li><p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Literal">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span><a class="headerlink" href="#typing.Literal" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解形式，用于定义“字面值类型”。</p>
<p><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 可以用来向类型检查器说明被注解的对象具有与所提供的字面量之一相同的值。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># 总是返回 True</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>      <span class="c1"># 通过类型检查</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># 类型检查错误</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 不能创建子类。在运行时，任意值均可作为 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 的类型参数，但类型检查器可以对此加以限制。字面量类型详见 <span class="target" id="index-167"></span><a class="pep reference external" href="https://peps.python.org/pep-0586/"><strong>PEP 586</strong></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9.1 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 现在能去除形参的重复。 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象的相等性比较不再依赖顺序。 现在如果有某个参数不为 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>，<code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象在相等性比较期间将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ClassVar">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ClassVar</span></span><a class="headerlink" href="#typing.ClassVar" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于标注类变量。</p>
<p>如 <span class="target" id="index-168"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> 所述，打包在 ClassVar 内的变量注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 类变量</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># 实例变量</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 仅接受类型，也不能使用下标。</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 本身不是类，不应用于 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 或 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>。<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 不改变 Python 运行时行为，但可以用于第三方类型检查器。例如，类型检查器会认为以下代码有错：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 错误，在实例上设置类变量</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># 这是可以的</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>现在 <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 可以被嵌套在 <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> 中，反之亦然。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Final">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Final</span></span><a class="headerlink" href="#typing.Final" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于向类型检查器表示最终名称。</p>
<p>不能在任何作用域中重新分配最终名称。类作用域中声明的最终名称不能在子类中重写。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 类型检查器将报告错误</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 类型检查器将报告错误</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-169"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>现在 <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> 可以被嵌套在 <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 中，反之亦然。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Required">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Required</span></span><a class="headerlink" href="#typing.Required" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于标记 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 键为必填项。</p>
<p>这主要用于 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> 的 TypedDict。有关更多详细信息，请参阅 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 和 <span class="target" id="index-170"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NotRequired">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NotRequired</span></span><a class="headerlink" href="#typing.NotRequired" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于标记 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 键为可能不存在的键。</p>
<p>详情参见 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 和 <span class="target" id="index-171"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ReadOnly">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ReadOnly</span></span><a class="headerlink" href="#typing.ReadOnly" title="Link to this definition">¶</a></dt>
<dd><p>一个特殊的类型标注构造，用于将 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 的项标记为只读。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
   <span class="n">title</span><span class="p">:</span> <span class="n">ReadOnly</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
   <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mutate_movie</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">Movie</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
   <span class="n">m</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1999</span>  <span class="c1"># allowed</span>
   <span class="n">m</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;The Matrix&quot;</span>  <span class="c1"># 类型检查错误</span>
</pre></div>
</div>
<p>这个属性没有运行时检查。</p>
<p>详见 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> 和 <span class="target" id="index-172"></span><a class="pep reference external" href="https://peps.python.org/pep-0705/"><strong>PEP 705</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Annotated">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Annotated</span></span><a class="headerlink" href="#typing.Annotated" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解形式，用于向注解添加特定于上下文的元数据。</p>
<p>使用注解 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 将元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 添加到给定类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 。使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 添加的元数据可以被静态分析工具使用，也可以在运行时使用。在运行时使用的情况下，元数据存储在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> 属性中。</p>
<p>如果库或工具遇到注解 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> ，并且没有针对这一元数据的特殊处理逻辑，则应该忽略该元数据，简单地将注解视为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 。因此， <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对于希望将注解用于 Python 的静态类型注解系统之外的目的的代码很有用。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 作为注解仍然允许对 <code class="docutils literal notranslate"><span class="pre">T</span></code> 进行静态类型检查，因为类型检查器将简单地忽略元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 。因此，<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 不同于 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> 装饰器，后者虽然也可以用于在类型注解系统范围之外添加注解，但是会完全禁用对函数或类的类型检查。</p>
<p>具体解释元数据的方式由遇到 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 注解的工具或库来负责。遇到 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型的工具或库可以扫描元数据的各个元素以确定其是否有意处理（比如使用 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> ）。</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">Annotated[&lt;type&gt;,</span> <span class="pre">&lt;metadata&gt;]</span></span></dt>
<dd></dd></dl>

<p>以下示例演示在进行区间范围分析时使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 将元数据添加到类型注解的方法：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ValueRange</span><span class="p">:</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>语法细节：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的第一个参数必须是有效的类型。</p></li>
<li><p>可提供多个元数据的元素（ <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 支持可变参数）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ctype</span><span class="p">:</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>由处理注解的工具决定是否允许向一个注解中添加多个元数据元素，以及如何合并这些注解。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 至少要有两个参数（ <code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code> 是无效的）</p></li>
<li><p>元数据元素的顺序会被保留，且影响等价检查：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>嵌套的 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型会被展平。元数据元素从最内层的注解开始依次展开：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>元数据中的重复元素不会被移除：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 可以与嵌套别名和泛型别名一起使用：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MaxLen</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># 当在类型注释中使用时，类型检查器会将“V”视为</span>
<span class="c1"># ``Annotated[list[tuple[int, int]], MaxLen(10)]``:</span>
<span class="nb">type</span> <span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 不能与已解包的 <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a> 一起使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Variadic</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>  <span class="c1"># 不可用</span>
</pre></div>
</div>
<p>这等价于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">T1</span></code> 、 <code class="docutils literal notranslate"><span class="pre">T2</span></code> 等都是 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVars</span></code></a> 。这种写法无效：应当只有一个类型被传递给 Annotated。</p>
</li>
<li><p>默认情况下， <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> 会去除注解中的元数据。传入 <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> 可以保留元数据：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_type_hints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: typing.Annotated[int, &#39;metadata&#39;], &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
</pre></div>
</div>
</li>
<li><p>在运行时，与特定 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型相关联的元数据可通过 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code> 属性来获取：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;very&quot;</span><span class="p">,</span> <span class="s2">&quot;important&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">typing.Annotated[int, &#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="go">(&#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;)</span>
</pre></div>
</div>
</li>
<li><p>在运行时 ，如果要检索由 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 封装的原始类型，请使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__origin__</span></code> 属性：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Password</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;secret&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Password</span><span class="o">.</span><span class="n">__origin__</span>
<span class="go">&lt;class &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>请注意使用 <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> 将返回 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 本身：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">Password</span><span class="p">)</span>
<span class="go">typing.Annotated</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-173"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> - 灵活的函数与变量标注</dt><dd><p>该 PEP 将 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 引入到标准库中。</p>
</dd>
</dl>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeIs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeIs</span></span><a class="headerlink" href="#typing.TypeIs" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于标记用户定义的谓词函数。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 能用来注解用户定义的谓词函数的返回值类型。<code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 接受单个类型参数。如此标注的函数在运行时应当有至少一个位置参数，并且返回一个布尔值。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 旨在方便 <em>类型收窄</em> -- 一个被静态类型检查器使用，用来更精准地决定程序代码流中表达式类型的技巧。通常类型收窄通过分析有条件的代码流并对代码块执行类型收窄实现。此处的条件表达式有时也被称为“类型谓词”。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; 类型谓词</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1">#  ``val`` 的类型缩小为 ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 否则， ``val`` 的类型缩小为 ``float``。</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>使用一个用户定义的布尔函数作为类型谓词有时很方便。这样的函数应当将 <code class="docutils literal notranslate"><span class="pre">TypeIs[...]</span></code> 或 <a class="reference internal" href="#typing.TypeGuard" title="typing.TypeGuard"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeGuard</span></code></a> 作为它的返回类型，以向静态类型检查器传达这个意图。<code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 的行为通常比 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 更直观，但在函数的输入与输出类型不兼容 (例如从 <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> 到 <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>) 或函数不会对所有收窄后类型的实例返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时不能使用。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeIs[NarrowedType]</span></code> 告诉静态类型检查器对于给定的函数：</p>
<ol class="arabic simple">
<li><p>返回一个布尔值。</p></li>
<li><p>如果返回值是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么其参数的类型收窄到参数本身类型与 <code class="docutils literal notranslate"><span class="pre">NarrowedType</span></code> 的并。</p></li>
<li><p>如果返回值是 <code class="docutils literal notranslate"><span class="pre">False</span></code>，那么其参数的类型收窄到排除 <code class="docutils literal notranslate"><span class="pre">NarrowedType</span></code>。</p></li>
</ol>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">TypeIs</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Parent</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span> <span class="k">pass</span>
<span class="nd">@final</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Unrelated</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_parent</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeIs</span><span class="p">[</span><span class="n">Parent</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Parent</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Child</span> <span class="o">|</span> <span class="n">Unrelated</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_parent</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="c1"># ``arg`` 的类型缩小为 ``Parent`` 和 ```Child`` 的交集，</span>
        <span class="c1"># 相当于 ``Child``.</span>
        <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Child</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ``arg`` 的类型缩小为 ``Parent`` 除外，所以仅剩 ``Unrelated``。</span>
        <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Unrelated</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 内的类型必须与函数参数类型契合，否则静态类型检查器会引发错误。编写不正确的 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 可能导致类型系统中出现不健全行为，以类型安全的方式编写这些函数是用户的责任。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 函数是一个类或实例方法，那么 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 中的类型将映射到（在 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 或 <code class="docutils literal notranslate"><span class="pre">self</span></code> 之后）第二个形参的类型。</p>
<p>简单来说，<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeIs[TypeB]:</span> <span class="pre">...</span></code> 意味着如果 <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">TypeB</span></code> 的实例，如果返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>，它就不是 <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>.的实例。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 同样可作用于类型变量，详见 <span class="target" id="index-174"></span><a class="pep reference external" href="https://peps.python.org/pep-0742/"><strong>PEP 742</strong></a> (使用 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 收窄类型) 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeGuard">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeGuard</span></span><a class="headerlink" href="#typing.TypeGuard" title="Link to this definition">¶</a></dt>
<dd><p>特殊类型注解构造，用于标记用户定义的谓词函数。</p>
<p>类型谓词函数是由用户定义的函数，它的返回值指示参数是否为某个特定类型的实例。<code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 和 <a class="reference internal" href="#typing.TypeIs" title="typing.TypeIs"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeIs</span></code></a> 用法相近，但是对类型检查行为有不同的影响（如下）。</p>
<p><code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> 告诉静态类型检查器，某函数：</p>
<ol class="arabic simple">
<li><p>返回一个布尔值。</p></li>
<li><p>如果返回值是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么其参数的类型是 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 内的类型。</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 也适用于类型变量。 详情参见 <span class="target" id="index-175"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a>。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># ``val`` 的类型缩小为 ``list[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ``val`` 的类型仍为 ``list[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 和 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 有以下不同：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 要求收窄的类型是输入类型的子类型，但 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 不要求。这主要是为了允许将 <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> 缩小为 <code class="docutils literal notranslate"><span class="pre">list[str]</span></code>，即使后者不是前者的子类型，因为 <code class="docutils literal notranslate"><span class="pre">list</span></code> 是不变的。</p></li>
<li><p>当 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 函数返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时，类型检查器会将变量的类型精确地收窄到 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 类型。当 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 函数返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时，类型检查程序可以结合先前已知的变量类型和 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 类型推断出更精确的类型。（从技术上讲，这叫做交类型。）</p></li>
<li><p>当 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 函数返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，类型检查器不会收窄变量的类型范围。当 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 函数返回 <code class="docutils literal notranslate"><span class="pre">False</span></code> 时，类型检查器可以收窄变量的类型范围至排除 <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> 类型。</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Unpack">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Unpack</span></span><a class="headerlink" href="#typing.Unpack" title="Link to this definition">¶</a></dt>
<dd><p>在概念上将对象标记为已解包的类型运算符。</p>
<p>例如，在一个 <a class="reference internal" href="#typevartuple"><span class="std std-ref">类型变量元组</span></a> 上使用解包运算符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 就等价于使用 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 来将该类型变量元组标记为已被解包:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="c1"># 实际所做的：</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>
</pre></div>
</div>
<p>实际上，<code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 在 <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVarTuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> 类型的上下文中可以和 <code class="docutils literal notranslate"><span class="pre">*</span></code> 互换使用。 你可能会看到 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 在较旧版本的 Python 中被显式地使用，这时 <code class="docutils literal notranslate"><span class="pre">*</span></code> 在特定场合则是无法使用的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在旧版本的 Python 中，TypeVarTuple 和 Unpack 位于</span>
<span class="c1"># `typing_extensions` 反向移植包中。</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVarTuple</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>         <span class="c1"># Python &lt;= 3.10 时的语法错误！</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>  <span class="c1"># 语义等效且向后兼容</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 也可以与 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> 一起使用以便在函数签名中对 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 进行类型标注:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># 此函数需要两个关键字参数 -</span>
<span class="c1"># 类型为 `str` 的 `name` 和类型为 `int` 的 `year`。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">Movie</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-176"></span><a class="pep reference external" href="https://peps.python.org/pep-0692/"><strong>PEP 692</strong></a> 了解将 <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> 用于 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 类型标注的更多细节。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types-and-type-aliases">
<h4>构造泛型类型与类型别名<a class="headerlink" href="#building-generic-types-and-type-aliases" title="Link to this heading">¶</a></h4>
<p>下列类不应被直接用作标注。 它们的设计目标是作为创建泛型类型和类型别名的构件。</p>
<p>这些对象可通过特殊语法 (<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参列表</span></a> 和 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句) 来创建。 为了与 Python 3.11 及更早版本的兼容性，它们也可不用专门的语法来创建，如下文所述。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generic</span></span><a class="headerlink" href="#typing.Generic" title="Link to this definition">¶</a></dt>
<dd><p>用于泛型类型的抽象基类。</p>
<p>泛型类型通常是通过在类名后添加一个类型形参列表来声明的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># 其他</span>
</pre></div>
</div>
<p>这样的类将隐式地继承自 <code class="docutils literal notranslate"><span class="pre">Generic</span></code>。 对于该语法的运行语义的讨论参见 <a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">语言参考</span></a>。</p>
<p>该类的用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">lookup_name</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">](</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
<p>此处函数名之后的圆括号是表示 <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">泛型函数</span></a>。</p>
<p>为了保持向下兼容性，泛型类也可通过显式地继承自 <code class="docutils literal notranslate"><span class="pre">Generic</span></code> 来声明。 在此情况下，类型形参必须单独声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># 其他</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class" id="typevar">
<dt class="sig sig-object py" id="typing.TypeVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar" title="Link to this definition">¶</a></dt>
<dd><p>类型变量。</p>
<p>构造类型变量的推荐方式是使用针对 <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">泛型函数</span></a>, <a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">泛型类</span></a> 和 <a class="reference internal" href="../reference/compound_stmts.html#generic-type-aliases"><span class="std std-ref">泛型类型别名</span></a> 的专门语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># T 是一个 TypeVar</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>此语法也可被用于创建绑定和约束类型变量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StrSequence</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">]:</span>  <span class="c1"># S 是具有 `str` 上方绑定的 TypeVar；</span>
    <span class="o">...</span>                     <span class="c1"># 我们可以说 S 是 &quot;被 `str` 绑定&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">StrOrBytesSequence</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)]:</span>  <span class="c1"># A 是约束为 str 或 bytes 的 TypeVar</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>不过，如有需要，也可通过手动方式来构造可重用的类型变量，就像这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># 可以是任意类型</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># 可以是任意 str 的子类型</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># 必须是 str 或 bytes</span>
</pre></div>
</div>
<p>类型变量的主要用处是为静态类型检查器提供支持。 它们可作为泛型类型以及泛型函数和类型别名定义的形参。 请参阅 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 了解有关泛型类型的更多信息。 泛型函数的作用方式如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">repeat</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span><span class="w"> </span><span class="nf">print_capitalized</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>请注意类型变量可以为 <em>已绑定</em>, <em>已约束</em>，或两者都不是，但不能同时为已绑定 <em>并且</em> 已约束。</p>
<p>类型变量的种类是在其通过 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参语法</span></a> 创建时或是在传入 <code class="docutils literal notranslate"><span class="pre">infer_variance=True</span></code> 时由类型检查器推断得到的。 手动创建的类型变量可通过传入 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 被显式地标记为协变或逆变。 在默认情况下，手动创建的类型变量为不变。 请参阅 <span class="target" id="index-177"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 和 <span class="target" id="index-178"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> 了解更多细节。</p>
<p>已绑定类型变量和已约束类型变量在一些重要的方面具有不同的语义。 使用 <em>已绑定</em> 类型变量意味着 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 将尽可能使用最专属的类型来解析:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 显示的类型是 str</span>

<span class="k">class</span><span class="w"> </span><span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># 显示的类型是 StringSubclass</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># 错误：int 不是 str 的子类型</span>
</pre></div>
</div>
<p>类型变量的上层绑定可以是一个具体类型、抽象类型（ABC 或 Protocol），甚至是多个类型的联合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 可以是任何具有 __abs__ 方法的内容</span>
<span class="k">def</span><span class="w"> </span><span class="nf">print_abs</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">SupportsAbs</span><span class="p">](</span><span class="n">arg</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Absolute value:&quot;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># 可以是联合 str|bytes 的任何子类型</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># 可以是任何具有 __abs__ 方法的内容</span>
</pre></div>
</div>
<p id="typing-constrained-typevar">但是，如果使用 <em>约束</em> 类型变量，则意味着 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 只能被解析为恰好是给定的约束之一:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 揭示的类型为 str</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 揭示的类型为 str，虽然传入的是 StringSubclass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># 错误：在一个函数调用中类型变量 &#39;A&#39; 可以为 str 或 bytes，但不可同时使用</span>
</pre></div>
</div>
<p>在运行时，<code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> 将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVar.__name__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__covariant__">
<span class="sig-name descname"><span class="pre">__covariant__</span></span><a class="headerlink" href="#typing.TypeVar.__covariant__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量是否已被显式地标记为 covariant。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__contravariant__">
<span class="sig-name descname"><span class="pre">__contravariant__</span></span><a class="headerlink" href="#typing.TypeVar.__contravariant__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量是否已被显式地标记为 contravariant。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__infer_variance__">
<span class="sig-name descname"><span class="pre">__infer_variance__</span></span><a class="headerlink" href="#typing.TypeVar.__infer_variance__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量的种类是否应由类型检查器来推断。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__bound__">
<span class="sig-name descname"><span class="pre">__bound__</span></span><a class="headerlink" href="#typing.TypeVar.__bound__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量的上层绑定，如果有的话。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对于通过 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参语法</span></a> 创建的类型变量，只有在属性被访问的时候才会对绑定求值，而不是在类型变量被创建的时候 (参见 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>)。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__constraints__">
<span class="sig-name descname"><span class="pre">__constraints__</span></span><a class="headerlink" href="#typing.TypeVar.__constraints__" title="Link to this definition">¶</a></dt>
<dd><p>一个包含对类型变量的约束的元组，如果有的话。A tuple containing the constraints of the type variable, if any.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>对于通过 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参语法</span></a> 创建的类型变量，只有在属性被访问的时候才会对约束求值，而不是在类型变量被创建的时候 (参见 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>)。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.TypeVar.__default__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量的默认值，如果没有默认值，则为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVar.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar.has_default" title="Link to this definition">¶</a></dt>
<dd><p>返回类型变量是否有默认值。它等价于检查 <a class="reference internal" href="#typing.TypeVar.__default__" title="typing.TypeVar.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> 是否为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> 单例，但它不要求对 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a> 的默认值求值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>类型变量现在可以通过使用 <span class="target" id="index-179"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> 引入的 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。 增加了 <code class="docutils literal notranslate"><span class="pre">infer_variance</span></code> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>增加了对默认值的支持。</p>
</div>
</dd></dl>

<dl class="py class" id="typevartuple">
<dt class="sig sig-object py" id="typing.TypeVarTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVarTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple" title="Link to this definition">¶</a></dt>
<dd><p>类型变量元组。 一种启用了 <em>variadic</em> 泛型的专属 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> 形式。</p>
<p>类型变量元组可以通过在 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参列表</span></a> 中使用名称前的单个星号 (<code class="docutils literal notranslate"><span class="pre">*</span></code>) 来声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">move_first_element_to_last</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">](</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>或者通过显式地唤起 <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> 构造器:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s2">&quot;Ts&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>一个普通类型变量将启用单个类型的形参化。 作为对比，一个类型变量元组通过将 <em>任意</em> 数量的类型变量封包在一个元组中来允许 <em>任意</em> 数量类型的形参化。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># T 绑定到 int，Ts 绑定到 ()</span>
<span class="c1"># 返回值为 (1,)，其类型为 tuple[int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>

<span class="c1"># T 绑定到 int，Ts 绑定到 (str,)</span>
<span class="c1"># 返回值为 (&#39;spam&#39;, 1)，其类型为 tuple[str, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">))</span>

<span class="c1"># T 绑定到 int，Ts 绑定到 (str, float)</span>
<span class="c1"># 返回值为 (&#39;spam&#39;, 3.0, 1)，其类型为 tuple[str, float, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># 这不能通过类型检查（并会在运行时执行失败）</span>
<span class="c1"># 因为 tuple[()] 与 tuple[T, *Ts] 不兼容</span>
<span class="c1"># （至少需要有一个元素）</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>请注意解包运算符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 在 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> 中的使用。 在概念上，你可以将 <code class="docutils literal notranslate"><span class="pre">Ts</span></code> 当作一个由类型变量组成的元组 <code class="docutils literal notranslate"><span class="pre">(T1,</span> <span class="pre">T2,</span> <span class="pre">...)</span></code>。 那么 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> 就将变为 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*(T1,</span> <span class="pre">T2,</span> <span class="pre">...)]</span></code>，这等价于 <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>。 （请注意在旧版本 Python 中，你可能会看到改用 <a class="reference internal" href="#typing.Unpack" title="typing.Unpack"><code class="xref py py-data docutils literal notranslate"><span class="pre">Unpack</span></code></a> 的写法，如 <code class="docutils literal notranslate"><span class="pre">Unpack[Ts]</span></code>。）</p>
<p>类型变量元组 <em>总是</em> 要被解包。 这有助于区分类型变量元组和普通类型变量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Ts</span>          <span class="c1"># 不可用</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Ts</span><span class="p">]</span>   <span class="c1"># 不可用</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>  <span class="c1"># 正确的做法</span>
</pre></div>
</div>
<p>类型变量元组可被用在与普通类型变量相同的上下文中。 例如，在类定义、参数和返回类型中:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array[*Shape]&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>类型变量元组可以很好地与普通类型变量结合在一起：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># 这样可以</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Array2</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">DType</span><span class="p">]:</span>  <span class="c1"># 这样也可以</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Height</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Width</span><span class="p">:</span> <span class="o">...</span>

<span class="n">float_array_1d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>     <span class="c1"># 完全可以</span>
<span class="n">int_array_2d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>  <span class="c1"># 是的，同样可以</span>
</pre></div>
</div>
<p>但是，请注意在一个类型参数或类型形参列表中最多只能有一个类型变量元组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>            <span class="c1"># 不可用</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># 不可用</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>最后，一个已解包的类型变量元组可以被用作 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 的类型标注:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">call_soon</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">](</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>相比非解包的 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 标注 —— 例如 <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">int</span></code>，它将指明 <em>所有</em> 参数均为 <code class="docutils literal notranslate"><span class="pre">int</span></code> —— <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code> 启用了对 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 中 <em>单个</em> 参数的类型的引用。 在此，这允许我们确保传入 <code class="docutils literal notranslate"><span class="pre">call_soon</span></code> 的 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 的类型与 <code class="docutils literal notranslate"><span class="pre">callback</span></code> 的（位置）参数的类型相匹配。</p>
<p>关于类型变量元组的更多细节，请参见 <span class="target" id="index-180"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVarTuple.__name__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量元组的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.TypeVarTuple.__default__" title="Link to this definition">¶</a></dt>
<dd><p>类型变量元组的默认值，如果没有默认值，则为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVarTuple.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple.has_default" title="Link to this definition">¶</a></dt>
<dd><p>返回类型变量元组是否有默认值。它等价于检查 <a class="reference internal" href="#typing.TypeVarTuple.__default__" title="typing.TypeVarTuple.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> 是否为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> 单例，但它不要求对 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a> 的默认值求值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>类型变量元组现在可以使用 <span class="target" id="index-181"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> 所引入的 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>增加了对默认值的支持。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ParamSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec" title="Link to this definition">¶</a></dt>
<dd><p>形参专属变量。 <a class="reference internal" href="#typevar"><span class="std std-ref">类型变量</span></a> 的一个专用版本。</p>
<p>In <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参列表</span></a>，形参规格可以使用两个星号 (<code class="docutils literal notranslate"><span class="pre">**</span></code>) 来声明:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">IntFunc</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>为了保持与 Python 3.11 及更早版本的兼容性，<code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 对象也可以这样创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>参数规范变量的存在主要是为了使静态类型检查器受益。 它们被用来将一个可调用对象的参数类型转发给另一个可调用对象的参数类型——这种模式通常出现在高阶函数和装饰器中。 它们只有在 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 中使用时才有效，或者作为 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 的第一个参数，或者作为用户定义的泛型的参数。 参见 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 以了解更多关于泛型的信息。</p>
<p>例如，为了给一个函数添加基本的日志记录，我们可以创建一个装饰器 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 来记录函数调用。 参数规范变量告诉类型检查器，传入装饰器的可调用对象和由其返回的新可调用对象有相互依赖的类型参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="k">def</span><span class="w"> </span><span class="nf">add_logging</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>如果没有 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>，之前标注这个的最简单方式是使用一个 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 并附带上层绑定 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>。 不过这会导致两个问题：</p>
<ol class="arabic simple">
<li><p>类型检查器不能对 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数进行类型检查，因为 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 的类型必须是 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。</p></li>
<li><p><a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 在返回 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数时，可能需要在 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 装饰器的主体中进行，或者必须告诉静态类型检查器忽略 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>。</p></li>
</ol>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#typing.ParamSpec.args" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#typing.ParamSpec.kwargs" title="Link to this definition">¶</a></dt>
<dd><p>由于 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 同时捕获了位置参数和关键字参数，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 可以用来将 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 分割成其组成部分。 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 代表给定调用中的位置参数的元组，只能用于注释 <code class="docutils literal notranslate"><span class="pre">*args</span></code>。 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 代表给定调用中的关键字参数到其值的映射，只能用于注释 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>。在运行时，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 分别是 <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> 和 <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a> 的实例。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.ParamSpec.__name__" title="Link to this definition">¶</a></dt>
<dd><p>形参规格的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.ParamSpec.__default__" title="Link to this definition">¶</a></dt>
<dd><p>形参规格的默认值，如果没有默认值，则为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.ParamSpec.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec.has_default" title="Link to this definition">¶</a></dt>
<dd><p>返回形参规格是否有默认值。它等价于检查 <a class="reference internal" href="#typing.ParamSpec.__default__" title="typing.ParamSpec.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> 是否为 <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> 单例，但它不要求对 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a> 的默认值求值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<p>用 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 创建的参数规范变量可以用来声明协变或逆变泛型类型。 参数 <code class="docutils literal notranslate"><span class="pre">bound</span></code> 也被接受，类似于 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>。 然而这些关键字的实际语义还有待决定。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>形参说明现在可以使用 <span class="target" id="index-182"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> 所引入的 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参</span></a> 语法来声明。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>增加了对默认值的支持。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>只有在全局范围内定义的参数规范变量可以被 pickle。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-183"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）</p></li>
<li><p><a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p></li>
<li><p><a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecArgs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecArgs</span></span><a class="headerlink" href="#typing.ParamSpecArgs" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.ParamSpecKwargs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecKwargs</span></span><a class="headerlink" href="#typing.ParamSpecKwargs" title="Link to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec`的参数和关键字参数属性。``ParamSpec`</span></code> 的 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 属性是 <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code> 的一个实例，<code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 是 <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code> 的一个实例。 它们的目的是用于运行时内部检查的，对静态类型检查器没有特殊意义。</p>
<p>在这些对象中的任何一个上调用 <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> 将返回原始的 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeAliasType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAliasType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeAliasType" title="Link to this definition">¶</a></dt>
<dd><p>通过 <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> 语句创建的类型别名的类型。</p>
<p>示例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Alias</span><span class="p">)</span>
<span class="go">&lt;class &#39;typing.TypeAliasType&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeAliasType.__name__" title="Link to this definition">¶</a></dt>
<dd><p>类型别名的名称：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;Alias&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.TypeAliasType.__module__" title="Link to this definition">¶</a></dt>
<dd><p>类型别名定义所在的模块名称:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__type_params__">
<span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#typing.TypeAliasType.__type_params__" title="Link to this definition">¶</a></dt>
<dd><p>类型别名的类型形参，或者如果别名不属于泛型则为一个空元组:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">ListOrSet</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ListOrSet</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">(T,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">NotGeneric</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NotGeneric</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__value__">
<span class="sig-name descname"><span class="pre">__value__</span></span><a class="headerlink" href="#typing.TypeAliasType.__value__" title="Link to this definition">¶</a></dt>
<dd><p>类型别名的值。 它将被 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">惰性求值</span></a>，因此别名定义中使用的名称将直到 <code class="docutils literal notranslate"><span class="pre">__value__</span></code> 属性被访问时才会被解析:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Mutually</span> <span class="o">=</span> <span class="n">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Recursive</span> <span class="o">=</span> <span class="n">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span>
<span class="go">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Mutually</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="other-special-directives">
<h4>其他特殊指令<a class="headerlink" href="#other-special-directives" title="Link to this heading">¶</a></h4>
<p>这些函数和类不应被直接用作标注。 它们的设计目标是作为创建和声明类型的构件。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.NamedTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NamedTuple</span></span><a class="headerlink" href="#typing.NamedTuple" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 的类型版本。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>这相当于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>为字段提供默认值，要在类体内赋值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>带默认值的字段必须在不带默认值的字段后面。</p>
<p>由此产生的类有一个额外的属性 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> ，给出一个 dict ，将字段名映射到字段类型。（字段名在 <code class="docutils literal notranslate"><span class="pre">_fields</span></code> 属性中，默认值在 <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> 属性中，这两者都是 <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a> API 的一部分。）</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 子类也支持文档字符串与方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;代表一位雇员。&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 子类也可以为泛型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>反向兼容用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在 Python 3.11 上创建通用 NamedTuple</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>

<span class="c1"># 函数语法也支持</span>
<span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>添加了对 <span class="target" id="index-184"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> 中变量注解句法的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6.1 版本发生变更: </span>添加了对默认值、方法、文档字符串的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性现已使用常规字典，不再使用 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 实例。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>移除了 <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 属性， 改用具有相同信息，但更标准的  <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加对泛型命名元组的支持。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>创建命名元组 NamedTuple 的关键字参数语法 (<code class="docutils literal notranslate"><span class="pre">NT</span> <span class="pre">=</span> <span class="pre">NamedTuple(&quot;NT&quot;,</span> <span class="pre">x=int)</span></code>) 未被写入文档且已被弃用，它将在 3.15 中被禁止。使用基于类的语法或函数式语法作为替代。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>使用函数式语法创建 NamedTuple 类时，不向 'fields' 形参传值(<code class="docutils literal notranslate"><span class="pre">NT</span> <span class="pre">=</span> <span class="pre">NamedTuple(&quot;NT&quot;)</span></code>) 或向 'fields' 形参传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> (<code class="docutils literal notranslate"><span class="pre">NT</span> <span class="pre">=</span> <span class="pre">NamedTuple(&quot;NT&quot;,</span> <span class="pre">None)</span></code>) 的行为已被弃用，且在 Python 3.15 中都将被禁止。要创建一个无字段的 NamedTuple 类，请使用 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">NT(NamedTuple):</span> <span class="pre">pass</span></code> 或 <code class="docutils literal notranslate"><span class="pre">NT</span> <span class="pre">=</span> <span class="pre">NamedTuple(&quot;NT&quot;,</span> <span class="pre">[])</span></code>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.NewType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NewType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="Link to this definition">¶</a></dt>
<dd><p>用于创建低开销的 <a class="reference internal" href="#distinct"><span class="std std-ref">独有类型</span></a> 的辅助类。</p>
<p><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 将被类型检查器视为一个独有类型。 但是，在运行时，调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 将原样返回其参数。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># 声明 NewType &quot;UserId&quot;</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 在运行时 &quot;UserId&quot; 将原样返回参数</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.NewType.__module__" title="Link to this definition">¶</a></dt>
<dd><p>新类型定义所在的模块。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.NewType.__name__" title="Link to this definition">¶</a></dt>
<dd><p>新类型的名称。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__supertype__">
<span class="sig-name descname"><span class="pre">__supertype__</span></span><a class="headerlink" href="#typing.NewType.__supertype__" title="Link to this definition">¶</a></dt>
<dd><p>新类型所基于的类型。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是函数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Protocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Generic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="Link to this definition">¶</a></dt>
<dd><p>协议类的基类。</p>
<p>协议类是这样定义的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>这些类主要与静态类型检查器搭配使用，用来识别结构子类型（静态鸭子类型），例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># 通过静态类型检查</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-185"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> 了解详情。 使用 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> 装饰的协议类（稍后将介绍）可作为只检查给定属性是否存在，而忽略其类型签名的简单的运行时协议。</p>
<p>Protocol 类可以是泛型，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">GenProto</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>在需要兼容 Python 3.11 或更早版本的代码中，可以这样编写泛型协议:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.runtime_checkable">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">runtime_checkable</span></span><a class="headerlink" href="#typing.runtime_checkable" title="Link to this definition">¶</a></dt>
<dd><p>用于把 Protocol 类标记为运行时协议。</p>
<p>该协议可以与 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 一起使用。应用于非协议的类时，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。该指令支持简易结构检查，与 <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 的 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 非常类似，只擅长做一件事。  例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>

<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Named</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="n">Named</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code> 将只检查所需方法或属性是否存在，而不检查它们的类型签名或类型。 例如，<a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> 是一个类，因此它通过了针对 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> 的 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 检查。 但是，<code class="docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__</span></code> 方法的存在只是引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并附带更具信息量的消息，因此它无法调用 (实例化) <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>针对运行时可检查协议的 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 检查相比针对非协议类的 <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> 检查可能会惊人的缓慢。 请考虑在性能敏感的代码中使用替代性写法如 <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 调用进行结构检查。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 的内部实现对于运行时可检查协议的检查会使用 <a class="reference internal" href="inspect.html#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getattr_static()</span></code></a> 来查找属性 (在之前版本中，会使用 <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>)。 因此，在 Python 3.12+ 上一些以前被认为是运行时可检查协议的实例的对象可能不再被认为是该协议的实例，反之亦反。 大多数用户不太可能受到这一变化的影响。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>一旦类被创建则运行时可检查协议的成员就会被视为在运行时“已冻结”。 在运行时可检查协议上打上猴子补丁属性仍然有效，但不会影响将对象与协议进行比较的 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 检查。 请参阅 <a class="reference internal" href="../whatsnew/3.12.html#whatsnew-typing-py312"><span class="std std-ref">&quot;Python 3.12 有什么新变化</span></a> 了解更多细节。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="Link to this definition">¶</a></dt>
<dd><p>把类型提示添加至字典的特殊构造器。在运行时，它是纯 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 声明一个字典类型，该类型预期所有实例都具有一组键集，其中，每个键都与对应类型的值关联。运行时不检查此预期，而是由类型检查器强制执行。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># 可以</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># 不能通过类型检查</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>另一种创建 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的方法是使用函数调用语法。第二个参数必须是一个 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 字面值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
<p>这种函数式语法允许定义因为是关键字或包含连字符而不是有效 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">标识符</span></a> 的键，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 引发 SyntaxError</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; 作为关键字</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># 名称带有连字符</span>

<span class="c1"># 功能语法</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>默认情况下，所有的键都必须出现在一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中。 可以使用 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 将单独的键标记为非必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="c1"># 替代语法</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p>这意味着一个 <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以省略 <code class="docutils literal notranslate"><span class="pre">label</span></code> 键。</p>
<p>也可以通过全部指定 <code class="docutils literal notranslate"><span class="pre">False</span></code> 将所有键都标记为默认非必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># 替代语法</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>这意味着一个 <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以省略任何一个键。 类型检查器只需要支持一个字面的 <code class="docutils literal notranslate"><span class="pre">False</span></code> 或 <code class="docutils literal notranslate"><span class="pre">True</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值。 <code class="docutils literal notranslate"><span class="pre">True</span></code> 是默认的，它使类主体中定义的所有项目都是必需的。</p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中单独的键可以使用 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 标记为必要的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># 替代语法</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型有可能使用基于类的语法从一个或多个其他 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型继承。用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> 有三个项目 : <code class="docutils literal notranslate"><span class="pre">x</span></code> , <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code> 。 其等价于定义:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 不能从非 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类继承，除了 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># 非 TypedDict 类</span>

<span class="k">class</span><span class="w"> </span><span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># 可以</span>

<span class="k">class</span><span class="w"> </span><span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># 引发 TypeError</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 也可以为泛型的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>要创建与 Python 3.11 或更低版本兼容的泛型 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>，请显式地从 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 继承：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以通过注解字典（参见 <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">注解最佳实践</span></a> 了解更多关于注解的最佳实践）、 <a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a> 、 <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> 和 <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> 进行内省。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__total__">
<span class="sig-name descname"><span class="pre">__total__</span></span><a class="headerlink" href="#typing.TypedDict.__total__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> 给出了 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值。 例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>该属性 <em>只</em> 反映传给当前 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类的 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值，而不反映这个类在语义上是否完整。 例如，一个 <code class="docutils literal notranslate"><span class="pre">__total__</span></code> 被设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可能有用 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 标记的键，或者它可能继承自另一个设置了 <code class="docutils literal notranslate"><span class="pre">total=False</span></code> 的 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>。 因此，使用 <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> 和 <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> 进行内省通常会更好。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__required_keys__">
<span class="sig-name descname"><span class="pre">__required_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="Link to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__optional_keys__">
<span class="sig-name descname"><span class="pre">__optional_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> 返回分别包含必要的和非必要的键的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象。</p>
<p>标记为 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 的键总是会出现在 <code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> 中而标记为 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 的键总是会出现在 <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> 中。</p>
<p>为了向下兼容 Python 3.10 及更老的版本，还可以使用继承机制在同一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中同时声明必要和非必要的键。 这是通过声明一个具有 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数值的 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 然后在另一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中继承它并使用不同的 <code class="docutils literal notranslate"><span class="pre">total</span></code> 值来实现的：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果使用了 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 或者如果以字符串形式给出标注，那么标注不会在定义 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 时被求值。 因此，<code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> 所依赖的运行时内省可能无法正常工作，这些属性的值也可能不正确。</p>
</div>
</dd></dl>

<p>对 <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> 的支持反映在下列属性中：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__readonly_keys__">
<span class="sig-name descname"><span class="pre">__readonly_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__readonly_keys__" title="Link to this definition">¶</a></dt>
<dd><p>一个包含所有只读键名称的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>。
带有 <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> 限定符的键被认为是只读的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__mutable_keys__">
<span class="sig-name descname"><span class="pre">__mutable_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__mutable_keys__" title="Link to this definition">¶</a></dt>
<dd><p>一个包含所有可变键名称的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>。
不带有 <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> 限定符的键被认为是可变的。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<p>更多示例与 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的详细规则，详见 <span class="target" id="index-186"></span><a class="pep reference external" href="https://peps.python.org/pep-0589/"><strong>PEP 589</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>增加了对将单独的键标记为 <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> 或 <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> 的支持。 参见 <span class="target" id="index-187"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>添加对泛型 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>移除了对使用关键字参数方法创建 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>添加了对 <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> 限定符的支持。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>使用函数式语法创建 TypedDict 类时，不向 'fields' 形参传值(<code class="docutils literal notranslate"><span class="pre">TD</span> <span class="pre">=</span> <span class="pre">TypedDict(&quot;TD&quot;)</span></code>) 或向 'fields' 形参传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> (<code class="docutils literal notranslate"><span class="pre">TD</span> <span class="pre">=</span> <span class="pre">TypedDict</span> <span class="pre">(&quot;TD&quot;,</span> <span class="pre">None)</span></code>) 的行为已被弃用，且在 Python 3.15 中都将被禁止。要创建一个无字段的 TypedDict 类，请使用 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">TD(TypedDict</span> <span class="pre">):</span> <span class="pre">pass</span></code> 或 <code class="docutils literal notranslate"><span class="pre">TD</span> <span class="pre">=</span> <span class="pre">TypedDict</span> <span class="pre">(&quot;TD&quot;,</span> <span class="pre">{})</span></code>。</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>协议<a class="headerlink" href="#protocols" title="Link to this heading">¶</a></h3>
<p>下列协议由 typing 模块提供并已全被装饰为 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">可在运行时检查的</span></code></a>。</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsAbs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsAbs</span></span><a class="headerlink" href="#typing.SupportsAbs" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code>，该方法与其返回类型协变。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsBytes</span></span><a class="headerlink" href="#typing.SupportsBytes" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsComplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsComplex</span></span><a class="headerlink" href="#typing.SupportsComplex" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsFloat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsFloat</span></span><a class="headerlink" href="#typing.SupportsFloat" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__float__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsIndex</span></span><a class="headerlink" href="#typing.SupportsIndex" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__index__</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsInt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsInt</span></span><a class="headerlink" href="#typing.SupportsInt" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__int__</span></code>。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsRound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsRound</span></span><a class="headerlink" href="#typing.SupportsRound" title="Link to this definition">¶</a></dt>
<dd><p>一个抽象基类，含一个抽象方法 <code class="docutils literal notranslate"><span class="pre">__round__</span></code>，该方法与其返回类型协变。</p>
</dd></dl>

</section>
<section id="abcs-for-working-with-io">
<h3>与 IO 相关的抽象基类<a class="headerlink" href="#abcs-for-working-with-io" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="typing.IO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">IO</span></span><a class="headerlink" href="#typing.IO" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.TextIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TextIO</span></span><a class="headerlink" href="#typing.TextIO" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.BinaryIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">BinaryIO</span></span><a class="headerlink" href="#typing.BinaryIO" title="Link to this definition">¶</a></dt>
<dd><p>泛型 <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> 及其子类 <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>、<code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code> 表示 I/O 流——例如 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 返回的对象——的类型。</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>函数与装饰器<a class="headerlink" href="#functions-and-decorators" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.cast">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="Link to this definition">¶</a></dt>
<dd><p>把一个值转换为指定的类型。</p>
<p>这会把值原样返回。对类型检查器而言这代表了返回值具有指定的类型，在运行时我们故意没有设计任何检查（我们希望让这尽量快）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_type" title="Link to this definition">¶</a></dt>
<dd><p>让静态类型检查器确认 <em>val</em> 具有推断为 <em>typ</em> 的类型。</p>
<p>在运行时这将不做任何事：它会原样返回第一个参数而没有任何检查或附带影响，无论参数的实际类型是什么。</p>
<p>当静态类型检查器遇到对 <code class="docutils literal notranslate"><span class="pre">assert_type()</span></code> 的调用时，如果该值不是指定的类型则会报错:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># OK，推断 `name` 的类型是 `str`</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># 类型检查器错误</span>
</pre></div>
</div>
<p>此函数适用于确保类型检查器对脚本的理解符合开发者的意图:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">complex_function</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
    <span class="c1"># 执行某些复杂的类型细化逻辑，</span>
    <span class="c1"># 在此之后我们希望推断出的类型为 `int`</span>
    <span class="o">...</span>
    <span class="c1"># 测试类型检查器能否正确理解我们的函数</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_never" title="Link to this definition">¶</a></dt>
<dd><p>让静态类型检查器确认一行代码是不可达的。</p>
<p>示例：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">as</span> <span class="n">unreachable</span><span class="p">:</span>
            <span class="n">assert_never</span><span class="p">(</span><span class="n">unreachable</span><span class="p">)</span>
</pre></div>
</div>
<p>在这里，标注允许类型检查器推断最后一种情况永远不会执行，因为 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 要么是 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 要么是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，而这两种选项都已被之前的情况覆盖了。</p>
<p>如果类型检查器发现对 <code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> 的调用是可达的，它将报告一个错误。 举例来说，如果 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 的类型标注改为 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">float</span></code>，则类型检查器将报告一个错误指出 <code class="docutils literal notranslate"><span class="pre">unreachable</span></code> 为 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 类型。 对于通过类型检查的 <code class="docutils literal notranslate"><span class="pre">assert_never</span></code> 调用，参数传入的推断类型必须为兜底类型 <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>，而不能为任何其他类型。</p>
<p>在运行时，如果调用此函数将抛出一个异常。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference external" href="https://typing.readthedocs.io/en/latest/guides/unreachable.html">Unreachable Code and Exhaustiveness Checking</a> 提供了更多关于静态类型穷举检查的信息。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.reveal_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">reveal_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.reveal_type" title="Link to this definition">¶</a></dt>
<dd><p>让静态类型检查器显示推测的表达式类型。</p>
<p>当静态类型检查器遇到一个对此函数的调用时，它将发出带有所推测参数类型的诊断信息。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 揭示的类型为 &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p>这在你想要调试你的类型检查器如何处理一段特定代码时很有用处。</p>
<p>在运行时，此函数会将其参数类型打印到 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> 并不加修改地返回该参数 (以允许该调用在表达式中使用):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 打印 &quot;Runtime type is int&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 打印 &quot;1&quot;</span>
</pre></div>
</div>
<p>请注意在运行时类型可能不同于类型静态检查器所推测的类型（明确程度可能更高也可能更低）。</p>
<p>大多数类型检查器都能在任何地方支持 <code class="docutils literal notranslate"><span class="pre">reveal_type()</span></code>，即使并未从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入该名称。 不过，从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入该名称将允许你的代码在运行时不会出现运行时错误并能更清晰地传递意图。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.dataclass_transform">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">dataclass_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_specifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.dataclass_transform" title="Link to this definition">¶</a></dt>
<dd><p>将一个对象标记为提供类似 <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass</span></code></a> 行为的装饰器。</p>
<p><code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 可被用于装饰类、元类或本身为装饰器的函数。 使用 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform()</span></code> 将让静态类型检查器知道被装饰的对象会执行以类似 <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 的方式来转换类的运行时“魔法”。</p>
<p>装饰器函数使用方式的例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_model</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@create_model</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>在基类上:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelBase</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>在元类上:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ModelBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMeta</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>上面定义的 <code class="docutils literal notranslate"><span class="pre">CustomerModel</span></code> 类将被类型检查器视为类似于使用 <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 创建的类。 例如，类型检查器将假定这些类具有接受 <code class="docutils literal notranslate"><span class="pre">id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法。</p>
<p>被装饰的类、元类或函数可以接受以下布尔值参数，类型检查器将假定它们具有与 <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> 装饰器相同的效果: <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code>, <code class="docutils literal notranslate"><span class="pre">match_args</span></code>, <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 和 <code class="docutils literal notranslate"><span class="pre">slots</span></code>。 这些参数的值 (<code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>) 必须可以被静态地求值。</p>
<p>传给 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 装饰器的参数可以被用来定制被装饰的类、元类或函数的默认行为:</p>
<dl class="field-list simple">
<dt class="field-odd">参数<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eq_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></li>
<li><p><strong>order_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">order</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><strong>kw_only_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p></li>
<li><p><strong>frozen_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) -- 指明如果调用方省略了 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 形参则应将其假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 .. versionadded:: 3.12</p></li>
<li><p><strong>field_specifiers</strong> (<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><em>Callable</em></a><em>[</em><em>...</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>...</em><em>]</em>) -- 指定一个受支持的类或描述字段的函数的静态列表，类似于 <a class="reference internal" href="dataclasses.html#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclasses.field()</span></code></a>。 默认为 <code class="docutils literal notranslate"><span class="pre">()</span></code>。</p></li>
<li><p><strong>**kwargs</strong> (<em>Any</em>) -- 接受任何其他关键字以便允许可能的未来扩展。</p></li>
</ul>
</dd>
</dl>
<p>类型检查器能识别下列字段设定器的可选形参:</p>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text"><strong>字段设定器的可识别形参</strong></span><a class="headerlink" href="#id7" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>形参名称</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">init</span></code></p></td>
<td><p>指明字段是否应当被包括在合成的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法中。 如果未指明，则 <code class="docutils literal notranslate"><span class="pre">init</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td><p>为字段提供默认值。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code></p></td>
<td><p>提供一个返回字段默认值的运行时回调。 如果 <code class="docutils literal notranslate"><span class="pre">default</span></code> 或 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 均未指定，则会假定字段没有默认值而在类被实例化时必须提供一个值。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">factory</span></code></p></td>
<td><p>字段说明符上 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 形参的别名。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code></p></td>
<td><p>指明字段是否应被标记为仅限关键字的。 如为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，字段将是仅限关键字的。 如为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，它将不是仅限关键字的。 如未指明，则将使用以 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 装饰的对象的 <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> 形参的值，或者如果该值也未指明，则将使用 <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> 上 <code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> 的值。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alias</span></code></p></td>
<td><p>提供字段的替代名称。 该替代名称会被用于合成的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 方法。</p></td>
</tr>
</tbody>
</table>
<p>在运行时，该装饰器会将其参数记录到被装饰对象的 <code class="docutils literal notranslate"><span class="pre">__dataclass_transform__</span></code> 属性。 它没有其他的运行时影响。</p>
<p>更多细节请参见 <span class="target" id="index-188"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function" id="overload">
<dt class="sig sig-object py" id="typing.overload">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">overload</span></span><a class="headerlink" href="#typing.overload" title="Link to this definition">¶</a></dt>
<dd><p>用于创建重载函数和方法的装饰器。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰器允许描述支持多参数类型不同组合的函数和方法。 一系列以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义必须带上恰好一个非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义（用于同一个函数/方法）。</p>
<p>以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义仅对类型检查器有用，因为它们将被非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义覆盖。 与此同时，非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的定义将在运行时使用但应被类型检查器忽略。 在运行时，直接调用以 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的函数将引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
<p>一个提供了比使用联合或类型变量更精确的类型的重载的示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># 以下为真正的实现</span>
</pre></div>
</div>
<p>请参阅 <span class="target" id="index-189"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 了解更多细节以及与其他类型语义的比较。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>现在可以使用 <a class="reference internal" href="#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_overloads()</span></code></a> 在运行时内省有重载的函数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_overloads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_overloads" title="Link to this definition">¶</a></dt>
<dd><p>为 <em>func</em> 返回以 <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a> 装饰的定义的序列。</p>
<p><em>func</em> 是用于实现过载函数的函数对象。 例如，根据文档中为 <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a> 给出的 <code class="docutils literal notranslate"><span class="pre">process</span></code> 定义，<code class="docutils literal notranslate"><span class="pre">get_overloads(process)</span></code> 将为所定义的三个过载函数返回由三个函数对象组成的序列。 如果在不带过载的函数上调用，<code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> 将返回一个空序列。</p>
<p><code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> 可被用来在运行时内省一个过载函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.clear_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">clear_overloads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.clear_overloads" title="Link to this definition">¶</a></dt>
<dd><p>清空内部注册表中所有已注册的重载。</p>
<p>这可用于回收注册表所使用的内存。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.final">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">final</span></span><a class="headerlink" href="#typing.final" title="Link to this definition">¶</a></dt>
<dd><p>表示最终化方法和最终化类的装饰器。</p>
<p>以 <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> 装饰一个方法将向类型检查器指明该方法不可在子类中被重载。 以 <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> 装饰一个类表示它不可被子类化。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 类型检查器报告错误</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># 类型检查器报告错误</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-190"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>该装饰器现在将尝试在被装饰的对象上设置 <code class="docutils literal notranslate"><span class="pre">__final__</span></code> 属性为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 这样，可以在运行时使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__final__&quot;,</span> <span class="pre">False)</span></code> 这样的检查来确定对象 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 是否已被标记为终结。 如果被装饰的对象不支持设置属性，该装饰器将不加修改地返回对象而不会引发异常。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check</span></span><a class="headerlink" href="#typing.no_type_check" title="Link to this definition">¶</a></dt>
<dd><p>标明注解不是类型提示的装饰器。</p>
<p>此作用方式类似于类或函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>。 对于类，它将递归地应用到该类中定义的所有方法和类（但不包括在其超类或子类中定义的方法）。 类型检查器将忽略带有此装饰器的函数或类的所有标注。</p>
<p><code class="docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code> 将原地改变被装饰的对象。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check_decorator">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check_decorator</span></span><a class="headerlink" href="#typing.no_type_check_decorator" title="Link to this definition">¶</a></dt>
<dd><p>让其他装饰器具有 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 效果的装饰器。</p>
<p>本装饰器用 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 里的装饰函数打包其他装饰器。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span><code class="docutils literal notranslate"><span class="pre">&#64;no_type_check_decorator</span></code> 没有任何类型检查器支持过，所以它被弃用，并将在 Python 3.15 中被移除。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.override">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">override</span></span><a class="headerlink" href="#typing.override" title="Link to this definition">¶</a></dt>
<dd><p>该装饰器指明子类中的某个方法是重载超类中的方法或属性。</p>
<p>如果一个以 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code> 装饰的方法实际未重载任何东西则类型检查器应当报告错误。 这有助于防止当基类发生修改而子类未进行相应修改而导致的问题。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 可以：重写 Base.log_status</span>
        <span class="o">...</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 类型检查器报告错误</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>没有对此特征属性的运行时检查。</p>
<p>该装饰器将尝试在被装饰的对象上设置 <code class="docutils literal notranslate"><span class="pre">__override__</span></code> 属性为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 这样，可以在运行时使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__override__&quot;,</span> <span class="pre">False)</span></code> 这样的检查来确定对象 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 是否已被标记为重载。 如果被装饰的对象不支持设置属性，该装饰器将不加修改地返回对象而不会引发异常。</p>
<p>更多细节参见 <span class="target" id="index-191"></span><a class="pep reference external" href="https://peps.python.org/pep-0698/"><strong>PEP 698</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.type_check_only">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">type_check_only</span></span><a class="headerlink" href="#typing.type_check_only" title="Link to this definition">¶</a></dt>
<dd><p>将类或函数标记为在运行时不可用的装饰器。</p>
<p>在运行时，该装饰器本身不可用。实现返回的是私有类实例时，它主要是用于标记在类型存根文件中定义的类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Response</span><span class="p">:</span>  <span class="c1"># 私有或在运行时不可用</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>注意，建议不要返回私有类实例，最好将之设为公共类。</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>内省辅助器<a class="headerlink" href="#introspection-helpers" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.get_type_hints">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_type_hints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="Link to this definition">¶</a></dt>
<dd><p>返回函数、方法、模块、类对象的类型提示的字典。</p>
<p>该函数通常与 <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code> 相同，但会对注解字典进行以下更改：</p>
<ul class="simple">
<li><p>以字符串字面形式或 <a class="reference internal" href="#typing.ForwardRef" title="typing.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 对象编码的前向引用会在 <em>globalns</em>, <em>localns</em> 和 (如适用) <em>obj</em> 的 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参</span></a> 命名空间中求值。如果没有传入 <em>globalns</em> 或 <em>localns</em>，则会从 <em>obj</em> 中推断出适当的命名空间字典。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> 被替换为 <a class="reference internal" href="types.html#types.NoneType" title="types.NoneType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.NoneType</span></code></a>。</p></li>
<li><p>如果在 <em>obj</em> 上应用了 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a>，返回一个空字典。</p></li>
<li><p>如果 <em>obj</em> 是一个类 <code class="docutils literal notranslate"><span class="pre">C</span></code>，则函数返回一个合并了 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的基类与 <code class="docutils literal notranslate"><span class="pre">C</span></code> 上的基类的字典。 这是通过遍历 <a class="reference internal" href="../reference/datamodel.html#type.__mro__" title="type.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">C.__mro__</span></code></a> 并迭代地合并 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 字典来实现的。 在 <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> 中较早出现的类上的标注总是会优先于在方法解析顺序中较晚出现的类的标注。</p></li>
<li><p>除非 <em>include_extras</em> 设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则函数会递归地将所有出现的 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">T</span></code> (详见 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a>)。</p></li>
</ul>
<p>另请参阅 <a class="reference internal" href="inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.get_annotations()</span></code></a>，这是一个以更直接方式返回注解的低级函数。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果 <em>obj</em> 注解中的任何前向引用不可解析或不是有效的 Python 代码，此函数将引发 <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 等异常。例如导入的 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a> 包含正向引用，或名称在 <a class="reference internal" href="#typing.TYPE_CHECKING" title="typing.TYPE_CHECKING"><code class="xref py py-data docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code></a> 下导入。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>增加了作为 <span class="target" id="index-192"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> 组成部分的 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 形参。 请参阅 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a> 文档了解详情。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span>在之前，如果设置了等于 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的默认值则会为函数和方法标注添加 <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code>。 现在标注将被不加修改地返回。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_origin">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="Link to this definition">¶</a></dt>
<dd><p>获取一个类型的不带下标的版本：对于 <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 形式的类型对象将返回 <code class="docutils literal notranslate"><span class="pre">X</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是一个内置类型或 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 类在 typing 模块中的别名，它将被正规化为原始的类。 如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是 <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> 或 <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a> 的实例，则返回下层的 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>。 对于不受支持的对象将返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Annotated</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_args">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="Link to this definition">¶</a></dt>
<dd><p>获取已执行所有下标的类型参数：对于 <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 形式的类型对象将返回 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是一个并集或是包含在另一个泛型类型中的 <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a>，则 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> 的顺序可能因类型缓存而与原始参数 <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 存在差异。 对于不受支持的对象将返回 <code class="docutils literal notranslate"><span class="pre">()</span></code>。</p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_protocol_members">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_protocol_members</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_protocol_members" title="Link to this definition">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 中定义的成员构成的集合。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">get_protocol_members</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">... </span>    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_protocol_members</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>如果参数不是协议，引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_protocol">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_protocol" title="Link to this definition">¶</a></dt>
<dd><p>检查一个类型是否为 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">is_protocol</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>    <span class="c1"># =&gt; True</span>
<span class="n">is_protocol</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># =&gt; False</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_typeddict">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_typeddict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_typeddict" title="Link to this definition">¶</a></dt>
<dd><p>检查一个类型是否为 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>。</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">assert</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>

<span class="c1"># TypedDict 是创建类型化字典的工厂，</span>
<span class="c1"># 不是类型化字典</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ForwardRef">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span><a class="headerlink" href="#typing.ForwardRef" title="Link to this definition">¶</a></dt>
<dd><p>用于字符串前向引用的内部类型表示的类。</p>
<p>例如，<code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> 会被隐式转换为 <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>。  <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> 不应由用户来实例化，但可以由内省工具使用。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><span class="target" id="index-193"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 泛型类型例如 <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code> 将不会被隐式地转换为 <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> 因而将不会自动解析为 <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NoDefault">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoDefault</span></span><a class="headerlink" href="#typing.NoDefault" title="Link to this definition">¶</a></dt>
<dd><p>一个用于指示类型形参没有默认值的哨兵对象。例如：</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">__default__</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">NoDefault</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">__default__</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>常量<a class="headerlink" href="#constant" title="Link to this heading">¶</a></h3>
<dl class="py data">
<dt class="sig sig-object py" id="typing.TYPE_CHECKING">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TYPE_CHECKING</span></span><a class="headerlink" href="#typing.TYPE_CHECKING" title="Link to this definition">¶</a></dt>
<dd><p>会被第 3 方静态类型检查器假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的特殊常量。 在运行时将为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">expensive_mod</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>第一个类型注解必须用引号标注，才能把它当作“前向引用”，从而在解释器运行时中隐藏 <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> 引用。局部变量的类型注释不会被评估，因此，第二个注解不需要用引号引起来。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>若用了 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>，函数定义时则不求值注解，直接把注解以字符串形式存在 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 里。这时毋需为注解打引号（见 <span class="target" id="index-194"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>）。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

</section>
<section id="deprecated-aliases">
<span id="generic-concrete-collections"></span><span id="id6"></span><h3>一些已被弃用的别名<a class="headerlink" href="#deprecated-aliases" title="Link to this heading">¶</a></h3>
<p>本模块给标准库中已有的类定义了许多别名，这些别名现已不再建议使用。起初 typing 模块包含这些别名是为了支持用 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 来参数化泛型类。然而，在 Python 3.9 中，对应的已有的类也支持了 <code class="docutils literal notranslate"><span class="pre">[]</span></code> (参见 <span class="target" id="index-195"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>)，因此这些别名了就成了多余的了。</p>
<p>这些多余的类型从 Python 3.9 起被弃用。然而，虽然它们可能会在某一时刻被移除，但目前还没有移除它们的计划。因此，解释器目前不会对这些别名发出弃用警告。</p>
<p>一旦确定了何时这些别名将被移除，解释器将比正式移除之时提前至少两个版本发出弃用警告 (deprecation warning)。但保证至少在 Python 3.14 之前，这些别名仍会留在 typing 模块中，并且不会引发弃用警告。</p>
<p>如果被类型检查器检查的程序旨在运行于 Python 3.9 或更高版本，则鼓励类型检查器标记出这些不建议使用的类型。</p>
<section id="aliases-to-built-in-types">
<span id="corresponding-to-built-in-types"></span><h4>内置类型的别名<a class="headerlink" href="#aliases-to-built-in-types" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的已弃用的别名。</p>
<p>请注意，注释参数时，最好使用抽象的多项集类型，如 <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>，而不是使用 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Dict</span></code>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-196"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.List">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">list,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 的已弃用的别名。</p>
<p>请注意，注释参数时，最好使用抽象的多项集类型，如 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 或 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>，而不是使用 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.List</span></code>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-197"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">set,</span> <span class="pre">MutableSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 的已弃用的别名。</p>
<p>请注意，注释参数时，最好使用抽象的多项集类型，如 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>，而不是使用 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 或 <a class="reference internal" href="#typing.Set" title="typing.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Set</span></code></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-198"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.FrozenSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">FrozenSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frozenset,</span> <span class="pre">AbstractSet[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-199"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Tuple">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><a class="headerlink" href="#typing.Tuple" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 的已弃用的别名。</p>
<p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> 是类型系统中的特例；更多详细信息请参见 <a class="reference internal" href="#annotating-tuples"><span class="std std-ref">标注元组</span></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-200"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[CT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的已弃用的别名。</p>
<p>有关在类型注解中使用 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 或 <code class="docutils literal notranslate"><span class="pre">typing.Type</span></code> 的详细信息，请参阅 <a class="reference internal" href="#type-of-class-objects"><span class="std std-ref">类对象的类型</span></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-201"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-types-in-collections">
<span id="corresponding-to-types-in-collections"></span><h4><a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 中的类型的别名。<a class="headerlink" href="#aliases-to-types-in-collections" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.DefaultDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">DefaultDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.defaultdict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-202"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.OrderedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">OrderedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.OrderedDict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-203"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.ChainMap,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-204"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Counter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.Counter,</span> <span class="pre">Dict[T,</span> <span class="pre">int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-205"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Deque">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deque,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-206"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-concrete-types">
<span id="other-concrete-types"></span><h4>其他具体类型的别名<a class="headerlink" href="#aliases-to-other-concrete-types" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#typing.Pattern" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#typing.Match" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 和 <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> 的返回类型的已弃用的别名。</p>
<p>这些类型（与对应的函数）是 <a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a> 上的泛型。 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> 可以被特化为 <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>；<code class="docutils literal notranslate"><span class="pre">Match</span></code> 可以被特化为 <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中的 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> 与 <code class="docutils literal notranslate"><span class="pre">Match</span></code> 类现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-207"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Text</span></span><a class="headerlink" href="#typing.Text" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的已弃用的别名。</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code> 被用来为 Python 2 代码提供向上兼容的路径：在 Python 2 中，<code class="docutils literal notranslate"><span class="pre">Text</span></code> 是 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 的别名。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Text</span></code> 时，值中必须包含 unicode 字符串，以兼容 Python 2 和 Python 3：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.11 版本弃用: </span>Python 2 已不再受支持，并且大部分类型检查器也都不再支持 Python 2 代码的类型检查。 目前还没有计划移除该别名，但建议用户使用 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 来代替 <code class="docutils literal notranslate"><span class="pre">Text</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-container-abcs-in-collections-abc">
<span id="corresponding-to-collections-in-collections-abc"></span><span id="abstract-base-classes"></span><h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中容器 ABC 的别名<a class="headerlink" href="#aliases-to-container-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.AbstractSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AbstractSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-208"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ByteString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="Link to this definition">¶</a></dt>
<dd><p>该类型代表了 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>、<a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 等字节序列类型。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.9, will be removed in version 3.14: </span>首选 <a class="reference internal" href="collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a>，或是 <code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">bytearray</span> <span class="pre">|</span> <span class="pre">memoryview</span></code> 这样的并集。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sized,</span> <span class="pre">Iterable[T_co],</span> <span class="pre">Container[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-209"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Container">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-210"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[tuple[KT_co,</span> <span class="pre">VT_co]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-211"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.KeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[KT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-212"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[KT],</span> <span class="pre">Generic[KT,</span> <span class="pre">VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-213"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sized</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-214"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableMapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-215"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-216"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AbstractSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-217"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Reversible[T_co],</span> <span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-218"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">Collection[_VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-219"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-asynchronous-abcs-in-collections-abc">
<span id="asynchronous-programming"></span><h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中异步 ABC 的别名<a class="headerlink" href="#aliases-to-asynchronous-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Coroutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Awaitable[ReturnType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 的已弃用的别名。</p>
<p>有关在注解类型中使用 <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">typing.Coroutine</span></code> 的详细信息，请参见 <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">标注生成器和协程</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-220"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 的已弃用的别名。</p>
<p>有关在注解类型中使用 <a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">typing.AsyncGenerator</span></code> 的详细信息，请参见 <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">标注生成器和协程</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-221"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">SendType</span></code> 形参现在有默认值。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-222"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-223"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Awaitable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 的已弃用的别名。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-224"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-abcs-in-collections-abc">
<span id="corresponding-to-other-types-in-collections-abc"></span><h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 中其他 ABC 的别名<a class="headerlink" href="#aliases-to-other-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 的已弃用的别名</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-225"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-226"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Callable">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span><a class="headerlink" href="#typing.Callable" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 的已弃用的别名。</p>
<p>有关如何在类型标注中使用 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">typing.Callable</span></code> 的详细信息请参阅 <a class="reference internal" href="#annotating-callables"><span class="std std-ref">标注可调用对象</span></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 现在支持下标操作（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）。参见 <span class="target" id="index-227"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 详情见 <span class="target" id="index-228"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Generator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 的已弃用的别名。</p>
<p>有关在注解类型中使用 <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">typing.Generator</span></code> 的详细信息，请参见 <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">标注生成器和协程</span></a>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-229"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>添加了发送和返回类型的默认值。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Hashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span><a class="headerlink" href="#typing.Hashable" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span>请改为直接使用 <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Reversible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-230"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sized">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span><a class="headerlink" href="#typing.Sized" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> 的已弃用的别名。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.12 版本弃用: </span>请改为直接使用 <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>。</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-contextlib-abcs">
<span id="context-manager-types"></span><h4><a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> ABC 的别名<a class="headerlink" href="#aliases-to-contextlib-abcs" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.ContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co,</span> <span class="pre">ExitT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 的已弃用的别名。</p>
<p>第一个类型形参 <code class="docutils literal notranslate"><span class="pre">T_co</span></code> 表示 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法返回值的类型。可选的第二个类型形参 <code class="docutils literal notranslate"><span class="pre">ExitT_co</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">|</span> <span class="pre">None</span></code>，它表示 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法返回的类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 现在支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-231"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>添加了可选的第二个类型形参，<code class="docutils literal notranslate"><span class="pre">ExitT_co</span></code>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co,</span> <span class="pre">AExitT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 的已弃用的别名。</p>
<p>第一个类型形参 <code class="docutils literal notranslate"><span class="pre">T_co</span></code> 表示 <a class="reference internal" href="../reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> 方法返回值的类型。可选的第二个类型形参 <code class="docutils literal notranslate"><span class="pre">AExitT_co</span></code> 默认为 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">|</span> <span class="pre">None</span></code>，它表示 <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> 方法返回的类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 现在 支持下标操作 (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)。 参见 <span class="target" id="index-232"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span>添加了可选的第二个类型形参，<code class="docutils literal notranslate"><span class="pre">AExitT_co</span></code>。</p>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="deprecation-timeline-of-major-features">
<h2>主要特性的弃用时间线<a class="headerlink" href="#deprecation-timeline-of-major-features" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">typing</span></code> 的某些特性被弃用，并且可能在将来的 Python 版本中被移除。下表总结了主要的弃用特性。该表可能会被更改，而且并没有列出所有的弃用特性。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>特性</p></th>
<th class="head"><p>弃用于</p></th>
<th class="head"><p>计划移除</p></th>
<th class="head"><p>PEP/问题</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>标准容器的 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 版本</p></td>
<td><p>3.9</p></td>
<td><p>未定（请参阅 <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">一些已被弃用的别名</span></a> 了解详情）</p></td>
<td><p><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.ByteString" title="typing.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ByteString</span></code></a></p></td>
<td><p>3.9</p></td>
<td><p>3.14</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/91896">gh-91896</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.Text" title="typing.Text"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Text</span></code></a></p></td>
<td><p>3.11</p></td>
<td><p>未确定</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.Hashable" title="typing.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Hashable</span></code></a> 和 <a class="reference internal" href="#typing.Sized" title="typing.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Sized</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>未确定</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/94309">gh-94309</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypeAlias</span></code></a></p></td>
<td><p>3.12</p></td>
<td><p>未确定</p></td>
<td><p><span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#typing.no_type_check_decorator" title="typing.no_type_check_decorator"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;typing.no_type_check_decorator</span></code></a></p></td>
<td><p>3.13</p></td>
<td><p>3.15</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/106309">gh-106309</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.AnyStr</span></code></a></p></td>
<td><p>3.13</p></td>
<td><p>3.18</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/105578">gh-105578</a></p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 对类型提示的支持</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">有关 Python 类型系统的规范说明</a></li>
<li><a class="reference internal" href="#type-aliases">类型别名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">标注可调用对象</a></li>
<li><a class="reference internal" href="#generics">泛型（Generic）</a></li>
<li><a class="reference internal" href="#annotating-tuples">标注元组</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">类对象的类型</a></li>
<li><a class="reference internal" href="#annotating-generators-and-coroutines">标注生成器和协程</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">用户定义的泛型类型</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 类型</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">名义子类型 vs 结构子类型</a></li>
<li><a class="reference internal" href="#module-contents">模块内容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特殊类型原语</a><ul>
<li><a class="reference internal" href="#special-types">特殊类型</a></li>
<li><a class="reference internal" href="#special-forms">特殊形式</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">构造泛型类型与类型别名</a></li>
<li><a class="reference internal" href="#other-special-directives">其他特殊指令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">协议</a></li>
<li><a class="reference internal" href="#abcs-for-working-with-io">与 IO 相关的抽象基类</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函数与装饰器</a></li>
<li><a class="reference internal" href="#introspection-helpers">内省辅助器</a></li>
<li><a class="reference internal" href="#constant">常量</a></li>
<li><a class="reference internal" href="#deprecated-aliases">一些已被弃用的别名</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">内置类型的别名</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 中的类型的别名。</a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">其他具体类型的别名</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中容器 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中异步 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 中其他 ABC 的别名</a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> ABC 的别名</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">主要特性的弃用时间线</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="development.html"
                          title="上一章">开发工具</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="pydoc.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文档生成器和在线帮助系统</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文档生成器和在线帮助系统"
             >下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 对类型提示的支持</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版权所有
    
      </a>
     2001-2025, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最后更新于 2月 06, 2025 (06:35 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>

  </body>
</html>