---
title: 
shortTitle: 编程范式及和设计模式的区别
description: 范式和模式的区别
icon: be
author: false
sideBar: false
isOriginal: true
date: 2023-8-31 9:58:00
category: 
  - GUI编程
tag: 
  - 编程范式
  - 设计模式
sticky: 
star: true
article: true
timeline: true
---

编程范式特点以及常见编程范式

<!-- more -->

## 编程范式

- 所谓编程范式就是指某种计算机语言编程的基本风格或典范模式。或说编程范式是将计算机要执行的任务按某种计算机语言编程的基本风格或典范模式进行概念化和结构化。
  前面我们说过，现在可使用的计算机编程语言多达数百种，它们能共处于一个时代，其中必然有着各自的特点和用途。当然也就导致了不同编程范式的存在。编程范式提供了（同时决定了）程序员对程序执行的看法。 `不同的编程语言会有不同的“编程范式”。`

- 学习一种编程语言，学习它的语法、技巧和开发工具固然重要，其实更重要的就是学习领会它的编程范式。编程范式往往被看成是心法，因为编程范式体现了编程过程中的思维方式，这种思维方式会浅易莫化引导我们的程序设计。所以通过对编程范式的学习和理解，能够增强编程语言的语感
- 这里需要强调的概念是：编程范式只是一个抽象的概念，它不针对任何具体的编程语言。一种编程范式可以在不同的计算机语言中出现。同时一种计算机语言也可以支持多种范式，这种计算机语言又被称为：多范式计算机语言。因为程序员在进行程序设计时可能会使用多种范式来进行编程。

- 我们说：编程范式是一个抽象的概念，它并不涉及或针对某特定的计算机编程语言。但是，当抽象的编程范式通过某种编程语言来具体体现时，就形成了该编程语言的核心编程理念，也就是形成该语言的编程思想。如：Java语言的核心编程理念就是面向对象编程。

## 一问一答

> 1. 那么编程范式与编程思想之间到底会有何不同之处呢？
>    应该讲，编程思想是针对某种特定的编程语言，并包含了该编程语言的全部特征。其中包括：范式、语法、结构、设计模式等等全部的内容。

> 2. “但事件驱动式不是也能作为设计模式吗？”
>
> “这倒并不矛盾。同样的思想用在整体系统的结构设计上，则称为架构模式；用在局部模块的细节实现上，则称为设计模式[1]；用在引导编程实践上，则称为编程范式。”

> 3. “如果一种语言不支持某种范式，那么还能用这种范式编程吗？”
>
> “语言不直接支持范式，只是说明它不属于该范式的语言，但还是可能求助工具来应用该范式。比如元编程可以借助Yacc或ANTLR来完成，AOP可以借助一些库或框架来实现。”冒号道，“正是依靠语言和工具的支持，编程范式得以建立起一套独特而完善的抽象机制和方法体系，从而为所倡导的世界观与方法论奠定基石。”

## 常见的编程范式

| 编程范式                                | 核心概念                        | 关键突破                                                     | 主要目的                                                     |
| :-------------------------------------- | :------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 代表语言                                | 运行机制                        | 实现原理                                                     | 常见应用                                                     |
| 命令式/过程式（Imperative/Procedural）  | 命令/过程（Command /Procedure） | 突破单一主程序和非结构化程序的限制                           | 模拟机器思维，实现自顶向下的模块设计                         |
| Fortran/Pascal/C                        | 命令执行                        | 引入逻辑控制和子程序                                         | 交互式、事件驱动型系统；数值计算等                           |
| 函数式/应用式（Functional/Applicative） | 函数（Function）                | 突破机器思维的限制                                           | 模拟数学思维，简化代码，减少副作用                           |
| Scheme/Haskell                          | 表达式计算                      | 引入高阶函数，将函数作为数据处理                             | 微积分计算；数学逻辑；博弈等                                 |
| 逻辑式（Logic）                         | 断言（Predicate）               | 突破逻辑与控制粘合的限制                                     | 专注逻辑分析，减少控制代码                                   |
| Prolog/Mercury                          | 逻辑推理                        | 利用推理引擎在已知的事实和规则的基础上进行逻辑推断           | 机器证明；专家系统；自然语言处理；语义网（semantic web）；决策分析；业务规则管理等 |
| 对象式（Object-Oriented）               | 对象（Object）                  | 突破数据与代码分离的限制                                     | 迎合人类认知模式，提高软件的易用性、重用性和可维护性         |
| Smalltalk/Java                          | 对象间信息交换                  | 引入封装、继承和多态机制                                     | 大型复杂交互式系统等                                         |
| 并发式/并行式（Concurrent/Parallel）    | 进程/线程（Process/Thread）     | 突破串行的限制                                               | 充分利用资源、提高运行效率、提高软件的响应能力、保证公平竞争 |
| Erlang/Oz                               | 进程/线程间通讯与同步           | 引入并行的线程模块以及模块间的通讯与同步机制                 | 图形用户界面；I/O处理；多任务系统如操作系统、网络服务器等；实时系统；嵌入式系统；计算密集型系统如科学计算、人工智能等 |
| 泛型式（Generic）                       | 算法（Algorithm）               | 突破静态类型语言的限制                                       | 提高算法的普适性                                             |
| Ada/Eiffel/C++                          | 算法实例化（多发生于编译期）    | 利用模板推迟类型指定                                         | 普适性算法如排序、搜索等；集合类容器等                       |
| 元编程（Metaprogramming）               | 元程序（Metaprogram）           | 突破语言的常规语法限制                                       | 减少手工编码，提升语言级别                                   |
| Lisp/Ruby/JavaScript                    | 动态生成代码或自动修改执行指令  | 利用代码生成或语言内建的反射（reflection）、动态等机制，将程序语言作为数据来处理 | 自动代码生成；定义结构化配置文件；IDE；编译器；解释器；人工智能；模型驱动架构（MDA）；领域特定语言（DSL）等 |
| 切面式（Aspect-Oriented）               | 切面（Aspect）                  | 突破横切关注点无法模块化的限制                               | 实现横切关注点分离                                           |
| AspectJ/AspectC++                       | 在接入点处执行建议              | 通过编织（weaving）将附加行为嵌入主体程序                    | 日志输出；代码跟踪；性能监控；异常处理；安全检查；事务管理等 |
| 事件驱动（Event-Driven）                | 事件（Event）                   | 突破顺序、同步的流程限制                                     | 调用者与被调用者在代码和时间上双重解耦                       |
| C#/VB.NET                               | 监听器收到事件通知后做出响应    | 引入控制反转和异步机制                                       | 图形用户界面；网络应用；服务器；操作系统；IoC框架；异步输入；DOM等 |

## 编程范式特点

1. 过程式编程的数据与代码脱节，**不方便维护**；
2. 函数式和逻辑式的开发效率一般比过程式高，但**运行效率**和**语言表现力**则有所不如；
3. 对象式编程用于**数学计算**、**符号处理等对象**特征淡薄的领域，在心理上缺乏认知基础，在运行效率上不如纯过程式，在开发效率上不如函数式；
4. 并发式编程增加了代码的**复杂度，**加重了程序员的负担；
5. 泛型式编程影响了代码的可读性，过度使用模块还可能造**成代码膨胀**（code bloat）；
6. 元编程**过于强大**，运用不当会**超出程序员的控制**，宜谨慎使用；
7. 切面式编程减少了程序的可**预测性**和**可控性**，同时给代码的跟踪调试带来一定困难，还可能造成性能上的损失；
8. 事件驱动式编程虽然也能用于同步的流程应用，但毕竟**机制更复杂**，没有普通的流程式编程那么自然易懂。

> - “在第一栏的编程范式及其代表语言中，为什么并发式的代表语言没有Java和C#，只有Erlang和Oz？”
>
>   “Java和C#虽然在语法和核心库中为并发编程提供了不少支持，但真正将并发范式融入基本设计理念的语言还得数Erlang、Oz这些较为冷门的语言。”冒号解释，“类似地，比起Java、JavaScript等语言来，C#和VB.NET在语言设计上对事件驱动式编程给予了更多的关注，因而更具代表性。” 

 

## 语言适用

> 设计模式的应用范围主要集中于静态的OOP语言，但也不排斥动态的或非OOP的语言。
>
> 当然随着语言的演进，也可能支持新的范式。比如，C++、Java和C#一开始都不支持泛型编程，C#对函数范式的支持也是逐渐加大的。
>
> C#和VB.NET专门为事件驱动式设计了event、delegate等关键字以及一些配套的便利机制。这里的代码不是指程序员写的源代码，而是指编译器生成的代码。



”

## 总结

- 编程范式针对的问题领域更广泛，提出的思想和方法更普适、更抽象、更系统。编程范式的核心价值在于：突破原有的编程方式的某些限制，带来新思维和新方法，从而进一步解放程序员的劳动力。

  “一种编程范式之所以能独树一帜，关键在于它突破了原有的编程方式的某些限制，带来革命性的新思维和新方法，进一步解放了程序员的劳动力。这便是范式的核心价值所在。”

- 设计模式重在设计，对语言和工具的要求不高，而编程范式需要建立一套抽象机制和方法体系，离不开语言或工具的支持。

- “设计模式是遵循设计原则的一些具体技巧，以保证代码的可维护性、可扩展性和可重用性为目的。它重在设计，对编程语言一般没有要求。

  编程范式则不同，对编程语言往往有专门的要求。通常所说的某某范式的语言，即指该语言对该范式在语法上有明确充分的支持，不需要借助其他的范式或工具。事实上，语言本来就是围绕其所倡导的核心范式来设计的。

>
> 参考：https://blog.csdn.net/a923544197/article/details/20416801

